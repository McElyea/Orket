[
  {
    "id": "001",
    "tier": 1,
    "description": "Deterministic sum CLI program.",
    "problem": "Build a runnable Python program that sums two numbers passed via command-line arguments.",
    "instruction": "Create a multi-file program with an executable CLI entrypoint that validates input and prints the sum.",
    "constraints": [
      "Use Python standard library only",
      "Deterministic output and error formatting",
      "Provide a real CLI entrypoint in agent_output/main.py"
    ],
    "io_examples": [
      {
        "input": "python agent_output/main.py 2 3",
        "output": "5\\n"
      },
      {
        "input": "python agent_output/main.py -1 4",
        "output": "3\\n"
      }
    ],
    "acceptance_contract": {
      "mode": "system",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "CLI returns expected output for valid cases",
        "CLI returns deterministic error behavior for invalid input",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "if __name__ == \"__main__\":",
        "argparse"
      ],
      "quality_forbidden_keywords": [
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "cli_examples",
      "entrypoint": "agent_output/main.py",
      "examples": [
        {
          "args": [
            "2",
            "3"
          ],
          "expected_stdout": "5\n",
          "expected_stderr": "",
          "expected_exit_code": 0
        },
        {
          "args": [
            "-1",
            "4"
          ],
          "expected_stdout": "3\n",
          "expected_stderr": "",
          "expected_exit_code": 0
        },
        {
          "args": [
            "0",
            "0"
          ],
          "expected_stdout": "0\n",
          "expected_stderr": "",
          "expected_exit_code": 0
        },
        {
          "args": [
            "2",
            "x"
          ],
          "expected_stdout": "",
          "expected_stderr": "error: arguments must be numeric\n",
          "expected_exit_code": 2
        }
      ]
    }
  },
  {
    "id": "002",
    "tier": 1,
    "description": "Deterministic concatenate-strings CLI program.",
    "problem": "Build a runnable Python program that concatenates exactly two input strings from CLI arguments.",
    "instruction": "Create a multi-file program with an executable CLI entrypoint that validates argument count and prints concatenated output.",
    "constraints": [
      "Use Python standard library only",
      "Deterministic output and error formatting",
      "Provide a real CLI entrypoint in agent_output/main.py"
    ],
    "io_examples": [
      {
        "input": "python agent_output/main.py foo bar",
        "output": "foobar\\n"
      },
      {
        "input": "python agent_output/main.py \"\" x",
        "output": "x\\n"
      }
    ],
    "acceptance_contract": {
      "mode": "system",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "CLI returns expected output for valid cases",
        "CLI returns deterministic error behavior for invalid input",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "if __name__ == \"__main__\":",
        "argparse"
      ],
      "quality_forbidden_keywords": [
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "cli_examples",
      "entrypoint": "agent_output/main.py",
      "examples": [
        {
          "args": [
            "foo",
            "bar"
          ],
          "expected_stdout": "foobar\\n",
          "expected_stderr": "",
          "expected_exit_code": 0
        },
        {
          "args": [
            "",
            "x"
          ],
          "expected_stdout": "x\\n",
          "expected_stderr": "",
          "expected_exit_code": 0
        },
        {
          "args": [
            "onlyone"
          ],
          "expected_stdout": "",
          "expected_stderr": "error: expected exactly 2 arguments\\n",
          "expected_exit_code": 2
        }
      ]
    }
  },
  {
    "id": "003",
    "tier": 1,
    "description": "Deterministic Fibonacci CLI program.",
    "problem": "Build a runnable Python program that outputs the first n Fibonacci numbers as a JSON list.",
    "instruction": "Create a multi-file program with an executable CLI entrypoint that parses n, validates it, and prints the sequence.",
    "constraints": [
      "Use Python standard library only",
      "Output JSON list exactly, followed by newline",
      "Provide a real CLI entrypoint in agent_output/main.py"
    ],
    "io_examples": [
      {
        "input": "python agent_output/main.py 0",
        "output": "[]\\n"
      },
      {
        "input": "python agent_output/main.py 5",
        "output": "[0, 1, 1, 2, 3]\\n"
      }
    ],
    "acceptance_contract": {
      "mode": "system",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "CLI returns expected output for valid cases",
        "CLI returns deterministic error behavior for invalid input",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "if __name__ == \"__main__\":",
        "argparse",
        "json"
      ],
      "quality_forbidden_keywords": [
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "cli_examples",
      "entrypoint": "agent_output/main.py",
      "examples": [
        {
          "args": [
            "0"
          ],
          "expected_stdout": "[]\\n",
          "expected_stderr": "",
          "expected_exit_code": 0
        },
        {
          "args": [
            "5"
          ],
          "expected_stdout": "[0, 1, 1, 2, 3]\\n",
          "expected_stderr": "",
          "expected_exit_code": 0
        },
        {
          "args": [
            "-1"
          ],
          "expected_stdout": "",
          "expected_stderr": "error: n must be a non-negative integer\\n",
          "expected_exit_code": 2
        }
      ]
    }
  },
  {
    "id": "004",
    "tier": 1,
    "description": "Deterministic reverse-string CLI program.",
    "problem": "Build a runnable Python program that reverses one input string from CLI arguments.",
    "instruction": "Create a multi-file program with an executable CLI entrypoint that validates argument count and prints reversed text.",
    "constraints": [
      "Use Python standard library only",
      "Deterministic output and error formatting",
      "Provide a real CLI entrypoint in agent_output/main.py"
    ],
    "io_examples": [
      {
        "input": "python agent_output/main.py abc",
        "output": "cba\\n"
      },
      {
        "input": "python agent_output/main.py racecar",
        "output": "racecar\\n"
      }
    ],
    "acceptance_contract": {
      "mode": "system",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "CLI returns expected output for valid cases",
        "CLI returns deterministic error behavior for invalid input",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "if __name__ == \"__main__\":",
        "argparse"
      ],
      "quality_forbidden_keywords": [
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "cli_examples",
      "entrypoint": "agent_output/main.py",
      "examples": [
        {
          "args": [
            "abc"
          ],
          "expected_stdout": "cba\\n",
          "expected_stderr": "",
          "expected_exit_code": 0
        },
        {
          "args": [
            ""
          ],
          "expected_stdout": "\\n",
          "expected_stderr": "",
          "expected_exit_code": 0
        },
        {
          "args": [],
          "expected_stdout": "",
          "expected_stderr": "error: expected exactly 1 argument\\n",
          "expected_exit_code": 2
        }
      ]
    }
  },
  {
    "id": "005",
    "tier": 1,
    "description": "Deterministic vowel-count CLI program.",
    "problem": "Build a runnable Python program that counts vowels in one input string and prints the count.",
    "instruction": "Create a multi-file program with an executable CLI entrypoint that validates argument count and prints the vowel count.",
    "constraints": [
      "Use Python standard library only",
      "Vowels are a,e,i,o,u (case-insensitive)",
      "Provide a real CLI entrypoint in agent_output/main.py"
    ],
    "io_examples": [
      {
        "input": "python agent_output/main.py hello",
        "output": "2\\n"
      },
      {
        "input": "python agent_output/main.py XYZ",
        "output": "0\\n"
      }
    ],
    "acceptance_contract": {
      "mode": "system",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "CLI returns expected output for valid cases",
        "CLI returns deterministic error behavior for invalid input",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "if __name__ == \"__main__\":",
        "argparse"
      ],
      "quality_forbidden_keywords": [
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "cli_examples",
      "entrypoint": "agent_output/main.py",
      "examples": [
        {
          "args": [
            "hello"
          ],
          "expected_stdout": "2\\n",
          "expected_stderr": "",
          "expected_exit_code": 0
        },
        {
          "args": [
            "AEIOU"
          ],
          "expected_stdout": "5\\n",
          "expected_stderr": "",
          "expected_exit_code": 0
        },
        {
          "args": [
            "a",
            "b"
          ],
          "expected_stdout": "",
          "expected_stderr": "error: expected exactly 1 argument\\n",
          "expected_exit_code": 2
        }
      ]
    }
  },
  {
    "id": "006",
    "tier": 1,
    "description": "Find maximum in list.",
    "problem": "Return the maximum value in a non-empty integer list.",
    "function_signature": "def max_in_list(values):",
    "instruction": "Implement max_in_list(values).",
    "constraints": [
      "values is non-empty",
      "Return integer"
    ],
    "io_examples": [
      {
        "input": [
          [
            1,
            3,
            2
          ]
        ],
        "output": 3
      },
      {
        "input": [
          [
            -5,
            -2,
            -9
          ]
        ],
        "output": -2
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def max_in_list(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "max_in_list",
      "examples": [
        {
          "args": [
            [
              1,
              3,
              2
            ]
          ],
          "expected": 3
        },
        {
          "args": [
            [
              -5,
              -2,
              -9
            ]
          ],
          "expected": -2
        }
      ]
    }
  },
  {
    "id": "007",
    "tier": 1,
    "description": "Check palindrome.",
    "problem": "Return True if the string is a palindrome, else False.",
    "function_signature": "def is_palindrome(s):",
    "instruction": "Implement is_palindrome(s).",
    "constraints": [
      "Case-sensitive exact match"
    ],
    "io_examples": [
      {
        "input": [
          "racecar"
        ],
        "output": true
      },
      {
        "input": [
          "hello"
        ],
        "output": false
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def is_palindrome(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "is_palindrome",
      "examples": [
        {
          "args": [
            "racecar"
          ],
          "expected": true
        },
        {
          "args": [
            "hello"
          ],
          "expected": false
        },
        {
          "args": [
            ""
          ],
          "expected": true
        }
      ]
    }
  },
  {
    "id": "008",
    "tier": 1,
    "description": "Factorial.",
    "problem": "Compute n! for non-negative integer n.",
    "function_signature": "def factorial(n):",
    "instruction": "Implement factorial(n).",
    "constraints": [
      "n >= 0",
      "0! = 1"
    ],
    "io_examples": [
      {
        "input": [
          0
        ],
        "output": 1
      },
      {
        "input": [
          5
        ],
        "output": 120
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def factorial(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "factorial",
      "examples": [
        {
          "args": [
            0
          ],
          "expected": 1
        },
        {
          "args": [
            1
          ],
          "expected": 1
        },
        {
          "args": [
            5
          ],
          "expected": 120
        }
      ]
    }
  },
  {
    "id": "009",
    "tier": 1,
    "description": "Sum of even numbers in list.",
    "problem": "Return the sum of all even integers in a list.",
    "function_signature": "def sum_even(values):",
    "instruction": "Implement sum_even(values).",
    "constraints": [
      "Return 0 if no evens"
    ],
    "io_examples": [
      {
        "input": [
          [
            1,
            2,
            3,
            4
          ]
        ],
        "output": 6
      },
      {
        "input": [
          [
            1,
            3,
            5
          ]
        ],
        "output": 0
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def sum_even(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "sum_even",
      "examples": [
        {
          "args": [
            [
              1,
              2,
              3,
              4
            ]
          ],
          "expected": 6
        },
        {
          "args": [
            [
              1,
              3,
              5
            ]
          ],
          "expected": 0
        }
      ]
    }
  },
  {
    "id": "010",
    "tier": 1,
    "description": "Unique values preserving order.",
    "problem": "Return a list of unique items in first-seen order.",
    "function_signature": "def unique_preserve_order(values):",
    "instruction": "Implement unique_preserve_order(values).",
    "constraints": [
      "Preserve first appearance order"
    ],
    "io_examples": [
      {
        "input": [
          [
            1,
            2,
            1,
            3,
            2
          ]
        ],
        "output": [
          1,
          2,
          3
        ]
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def unique_preserve_order(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "unique_preserve_order",
      "examples": [
        {
          "args": [
            [
              1,
              2,
              1,
              3,
              2
            ]
          ],
          "expected": [
            1,
            2,
            3
          ]
        },
        {
          "args": [
            [
              4,
              4,
              4
            ]
          ],
          "expected": [
            4
          ]
        }
      ]
    }
  },
  {
    "id": "011",
    "tier": 2,
    "description": "Word frequency map.",
    "problem": "Given a sentence, return a dictionary of lowercase word counts split on whitespace.",
    "function_signature": "def word_frequency(text):",
    "instruction": "Implement word_frequency(text).",
    "constraints": [
      "Lowercase keys",
      "Whitespace split only"
    ],
    "io_examples": [
      {
        "input": [
          "One two two"
        ],
        "output": {
          "one": 1,
          "two": 2
        }
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def word_frequency(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "word_frequency",
      "examples": [
        {
          "args": [
            "One two two"
          ],
          "expected": {
            "one": 1,
            "two": 2
          }
        },
        {
          "args": [
            ""
          ],
          "expected": {}
        }
      ]
    }
  },
  {
    "id": "012",
    "tier": 2,
    "description": "Merge sorted lists.",
    "problem": "Merge two sorted integer lists into a single sorted list.",
    "function_signature": "def merge_sorted(a, b):",
    "instruction": "Implement merge_sorted(a, b).",
    "constraints": [
      "Input lists already sorted ascending"
    ],
    "io_examples": [
      {
        "input": [
          [
            1,
            3,
            5
          ],
          [
            2,
            4
          ]
        ],
        "output": [
          1,
          2,
          3,
          4,
          5
        ]
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def merge_sorted(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "merge_sorted",
      "examples": [
        {
          "args": [
            [
              1,
              3,
              5
            ],
            [
              2,
              4
            ]
          ],
          "expected": [
            1,
            2,
            3,
            4,
            5
          ]
        },
        {
          "args": [
            [],
            [
              1,
              2
            ]
          ],
          "expected": [
            1,
            2
          ]
        }
      ]
    }
  },
  {
    "id": "013",
    "tier": 2,
    "description": "Rotate list right.",
    "problem": "Rotate a list to the right by k steps.",
    "function_signature": "def rotate_right(values, k):",
    "instruction": "Implement rotate_right(values, k).",
    "constraints": [
      "k may be >= len(values)",
      "Return new list"
    ],
    "io_examples": [
      {
        "input": [
          [
            1,
            2,
            3,
            4
          ],
          1
        ],
        "output": [
          4,
          1,
          2,
          3
        ]
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def rotate_right(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "rotate_right",
      "examples": [
        {
          "args": [
            [
              1,
              2,
              3,
              4
            ],
            1
          ],
          "expected": [
            4,
            1,
            2,
            3
          ]
        },
        {
          "args": [
            [
              1,
              2,
              3
            ],
            4
          ],
          "expected": [
            3,
            1,
            2
          ]
        }
      ]
    }
  },
  {
    "id": "014",
    "tier": 2,
    "description": "Second largest distinct number.",
    "problem": "Return the second largest distinct integer in a list.",
    "function_signature": "def second_largest(values):",
    "instruction": "Implement second_largest(values).",
    "constraints": [
      "At least 2 distinct values exist"
    ],
    "io_examples": [
      {
        "input": [
          [
            5,
            1,
            5,
            3
          ]
        ],
        "output": 3
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def second_largest(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "second_largest",
      "examples": [
        {
          "args": [
            [
              5,
              1,
              5,
              3
            ]
          ],
          "expected": 3
        },
        {
          "args": [
            [
              10,
              8,
              9
            ]
          ],
          "expected": 9
        }
      ]
    }
  },
  {
    "id": "015",
    "tier": 2,
    "description": "Anagram check.",
    "problem": "Return True if two strings are anagrams, ignoring spaces and case.",
    "function_signature": "def are_anagrams(a, b):",
    "instruction": "Implement are_anagrams(a, b).",
    "constraints": [
      "Ignore spaces",
      "Case-insensitive"
    ],
    "io_examples": [
      {
        "input": [
          "Listen",
          "Silent"
        ],
        "output": true
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def are_anagrams(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "are_anagrams",
      "examples": [
        {
          "args": [
            "Listen",
            "Silent"
          ],
          "expected": true
        },
        {
          "args": [
            "a gentleman",
            "elegant man"
          ],
          "expected": true
        },
        {
          "args": [
            "foo",
            "bar"
          ],
          "expected": false
        }
      ]
    }
  },
  {
    "id": "016",
    "tier": 3,
    "description": "Roman numeral to integer.",
    "problem": "Convert a Roman numeral string into an integer.",
    "function_signature": "def roman_to_int(s):",
    "instruction": "Implement roman_to_int(s).",
    "constraints": [
      "Support standard subtractive notation"
    ],
    "io_examples": [
      {
        "input": [
          "III"
        ],
        "output": 3
      },
      {
        "input": [
          "MCMXCIV"
        ],
        "output": 1994
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def roman_to_int(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "roman_to_int",
      "examples": [
        {
          "args": [
            "III"
          ],
          "expected": 3
        },
        {
          "args": [
            "LVIII"
          ],
          "expected": 58
        },
        {
          "args": [
            "MCMXCIV"
          ],
          "expected": 1994
        }
      ]
    }
  },
  {
    "id": "017",
    "tier": 3,
    "description": "Longest common prefix.",
    "problem": "Return the longest common prefix string amongst a list of strings.",
    "function_signature": "def longest_common_prefix(values):",
    "instruction": "Implement longest_common_prefix(values).",
    "constraints": [
      "Return empty string if none"
    ],
    "io_examples": [
      {
        "input": [
          [
            "flower",
            "flow",
            "flight"
          ]
        ],
        "output": "fl"
      },
      {
        "input": [
          [
            "dog",
            "racecar",
            "car"
          ]
        ],
        "output": ""
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def longest_common_prefix(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "longest_common_prefix",
      "examples": [
        {
          "args": [
            [
              "flower",
              "flow",
              "flight"
            ]
          ],
          "expected": "fl"
        },
        {
          "args": [
            [
              "dog",
              "racecar",
              "car"
            ]
          ],
          "expected": ""
        }
      ]
    }
  },
  {
    "id": "018",
    "tier": 3,
    "description": "Balanced parentheses.",
    "problem": "Return True if string containing ()[]{} is balanced.",
    "function_signature": "def is_balanced(s):",
    "instruction": "Implement is_balanced(s).",
    "constraints": [
      "Only brackets are relevant"
    ],
    "io_examples": [
      {
        "input": [
          "([]){}"
        ],
        "output": true
      },
      {
        "input": [
          "([)]"
        ],
        "output": false
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def is_balanced(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "is_balanced",
      "examples": [
        {
          "args": [
            "([]){}"
          ],
          "expected": true
        },
        {
          "args": [
            "([)]"
          ],
          "expected": false
        },
        {
          "args": [
            ""
          ],
          "expected": true
        }
      ]
    }
  },
  {
    "id": "019",
    "tier": 3,
    "description": "Run-length encoding.",
    "problem": "Encode a string with run-length encoding, e.g. aaabb -> a3b2.",
    "function_signature": "def rle_encode(s):",
    "instruction": "Implement rle_encode(s).",
    "constraints": [
      "Return empty for empty input"
    ],
    "io_examples": [
      {
        "input": [
          "aaabb"
        ],
        "output": "a3b2"
      },
      {
        "input": [
          "abcd"
        ],
        "output": "a1b1c1d1"
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def rle_encode(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "rle_encode",
      "examples": [
        {
          "args": [
            "aaabb"
          ],
          "expected": "a3b2"
        },
        {
          "args": [
            "abcd"
          ],
          "expected": "a1b1c1d1"
        },
        {
          "args": [
            ""
          ],
          "expected": ""
        }
      ]
    }
  },
  {
    "id": "020",
    "tier": 3,
    "description": "Group anagrams.",
    "problem": "Group words that are anagrams and return sorted groups for determinism.",
    "function_signature": "def group_anagrams(values):",
    "instruction": "Implement group_anagrams(values).",
    "constraints": [
      "Deterministic output ordering",
      "Sort each group and the outer list"
    ],
    "io_examples": [
      {
        "input": [
          [
            "eat",
            "tea",
            "tan",
            "ate",
            "nat",
            "bat"
          ]
        ],
        "output": [
          [
            "ate",
            "eat",
            "tea"
          ],
          [
            "bat"
          ],
          [
            "nat",
            "tan"
          ]
        ]
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def group_anagrams(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "group_anagrams",
      "examples": [
        {
          "args": [
            [
              "eat",
              "tea",
              "tan",
              "ate",
              "nat",
              "bat"
            ]
          ],
          "expected": [
            [
              "ate",
              "eat",
              "tea"
            ],
            [
              "bat"
            ],
            [
              "nat",
              "tan"
            ]
          ]
        }
      ]
    }
  },
  {
    "id": "021",
    "tier": 4,
    "description": "Longest substring without repeating characters.",
    "problem": "Return the length of the longest substring without duplicate characters.",
    "function_signature": "def longest_unique_substring_len(s):",
    "instruction": "Implement longest_unique_substring_len(s) using deterministic logic.",
    "constraints": [
      "Input is ASCII string",
      "Return integer length"
    ],
    "io_examples": [
      {
        "input": [
          "abcabcbb"
        ],
        "output": 3
      },
      {
        "input": [
          "bbbbb"
        ],
        "output": 1
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def longest_unique_substring_len(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "longest_unique_substring_len",
      "examples": [
        {
          "args": [
            "abcabcbb"
          ],
          "expected": 3
        },
        {
          "args": [
            "bbbbb"
          ],
          "expected": 1
        },
        {
          "args": [
            "pwwkew"
          ],
          "expected": 3
        }
      ]
    }
  },
  {
    "id": "022",
    "tier": 4,
    "description": "Two-sum indices with deterministic pair selection.",
    "problem": "Return [i, j] such that values[i] + values[j] == target using lexicographically earliest pair (smallest i, then smallest j).",
    "function_signature": "def two_sum_indices(values, target):",
    "instruction": "Implement two_sum_indices(values, target). Iterate i from left to right and j from i+1 to end; return the first matching pair. Return [] if none.",
    "constraints": [
      "Indices must satisfy i < j",
      "Must return lexicographically earliest valid pair",
      "Do not choose arbitrary hash-map pair when multiple pairs exist"
    ],
    "io_examples": [
      {
        "input": [
          [
            2,
            7,
            11,
            15
          ],
          9
        ],
        "output": [
          0,
          1
        ]
      },
      {
        "input": [
          [
            3,
            2,
            4,
            3
          ],
          6
        ],
        "output": [
          0,
          3
        ]
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def two_sum_indices(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "two_sum_indices",
      "examples": [
        {
          "args": [
            [
              2,
              7,
              11,
              15
            ],
            9
          ],
          "expected": [
            0,
            1
          ]
        },
        {
          "args": [
            [
              3,
              2,
              4,
              3
            ],
            6
          ],
          "expected": [
            0,
            3
          ]
        },
        {
          "args": [
            [
              1,
              5,
              1,
              5
            ],
            6
          ],
          "expected": [
            0,
            1
          ]
        },
        {
          "args": [
            [
              1,
              2,
              3
            ],
            7
          ],
          "expected": []
        }
      ]
    }
  },
  {
    "id": "023",
    "tier": 4,
    "description": "Product of array except self.",
    "problem": "Return an array output where output[i] is the product of all values except values[i].",
    "function_signature": "def product_except_self(values):",
    "instruction": "Implement product_except_self(values) without using division.",
    "constraints": [
      "Input length >= 1",
      "Return list of integers"
    ],
    "io_examples": [
      {
        "input": [
          [
            1,
            2,
            3,
            4
          ]
        ],
        "output": [
          24,
          12,
          8,
          6
        ]
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def product_except_self(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "product_except_self",
      "examples": [
        {
          "args": [
            [
              1,
              2,
              3,
              4
            ]
          ],
          "expected": [
            24,
            12,
            8,
            6
          ]
        },
        {
          "args": [
            [
              0,
              1,
              2,
              3
            ]
          ],
          "expected": [
            6,
            0,
            0,
            0
          ]
        },
        {
          "args": [
            [
              -1,
              1,
              0,
              -3,
              3
            ]
          ],
          "expected": [
            0,
            0,
            9,
            0,
            0
          ]
        }
      ]
    }
  },
  {
    "id": "024",
    "tier": 4,
    "description": "Merge overlapping intervals.",
    "problem": "Given a list of [start, end] intervals, merge overlaps and return sorted non-overlapping intervals.",
    "function_signature": "def merge_intervals(intervals):",
    "instruction": "Implement merge_intervals(intervals).",
    "constraints": [
      "Sort by start before merge",
      "Return deterministic interval order"
    ],
    "io_examples": [
      {
        "input": [
          [
            [
              1,
              3
            ],
            [
              2,
              6
            ],
            [
              8,
              10
            ],
            [
              15,
              18
            ]
          ]
        ],
        "output": [
          [
            1,
            6
          ],
          [
            8,
            10
          ],
          [
            15,
            18
          ]
        ]
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def merge_intervals(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "merge_intervals",
      "examples": [
        {
          "args": [
            [
              [
                1,
                3
              ],
              [
                2,
                6
              ],
              [
                8,
                10
              ],
              [
                15,
                18
              ]
            ]
          ],
          "expected": [
            [
              1,
              6
            ],
            [
              8,
              10
            ],
            [
              15,
              18
            ]
          ]
        },
        {
          "args": [
            [
              [
                1,
                4
              ],
              [
                4,
                5
              ]
            ]
          ],
          "expected": [
            [
              1,
              5
            ]
          ]
        }
      ]
    }
  },
  {
    "id": "025",
    "tier": 4,
    "description": "Minimum window substring.",
    "problem": "Return the minimum-length substring of s that contains all characters of t (with multiplicity), or empty string.",
    "function_signature": "def min_window_substring(s, t):",
    "instruction": "Implement min_window_substring(s, t).",
    "constraints": [
      "Case-sensitive",
      "Return left-most minimum when multiple windows share length"
    ],
    "io_examples": [
      {
        "input": [
          "ADOBECODEBANC",
          "ABC"
        ],
        "output": "BANC"
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def min_window_substring(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "min_window_substring",
      "examples": [
        {
          "args": [
            "ADOBECODEBANC",
            "ABC"
          ],
          "expected": "BANC"
        },
        {
          "args": [
            "a",
            "aa"
          ],
          "expected": ""
        },
        {
          "args": [
            "ab",
            "b"
          ],
          "expected": "b"
        }
      ]
    }
  },
  {
    "id": "026",
    "tier": 4,
    "description": "Search in rotated sorted array.",
    "problem": "Given a rotated sorted array with unique elements, return index of target or -1.",
    "function_signature": "def search_rotated(values, target):",
    "instruction": "Implement search_rotated(values, target).",
    "constraints": [
      "Values are unique",
      "Return integer index"
    ],
    "io_examples": [
      {
        "input": [
          [
            4,
            5,
            6,
            7,
            0,
            1,
            2
          ],
          0
        ],
        "output": 4
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def search_rotated(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "search_rotated",
      "examples": [
        {
          "args": [
            [
              4,
              5,
              6,
              7,
              0,
              1,
              2
            ],
            0
          ],
          "expected": 4
        },
        {
          "args": [
            [
              4,
              5,
              6,
              7,
              0,
              1,
              2
            ],
            3
          ],
          "expected": -1
        },
        {
          "args": [
            [
              1
            ],
            0
          ],
          "expected": -1
        }
      ]
    }
  },
  {
    "id": "027",
    "tier": 4,
    "description": "Coin change minimum coins.",
    "problem": "Return the minimum number of coins needed to make amount, or -1 if impossible.",
    "function_signature": "def coin_change_min(coins, amount):",
    "instruction": "Implement coin_change_min(coins, amount).",
    "constraints": [
      "Coin values are positive integers",
      "Use deterministic DP logic"
    ],
    "io_examples": [
      {
        "input": [
          [
            1,
            2,
            5
          ],
          11
        ],
        "output": 3
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def coin_change_min(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "coin_change_min",
      "examples": [
        {
          "args": [
            [
              1,
              2,
              5
            ],
            11
          ],
          "expected": 3
        },
        {
          "args": [
            [
              2
            ],
            3
          ],
          "expected": -1
        },
        {
          "args": [
            [
              1
            ],
            0
          ],
          "expected": 0
        }
      ]
    }
  },
  {
    "id": "028",
    "tier": 4,
    "description": "Count subsets summing to target.",
    "problem": "Return how many subsets of values sum exactly to target.",
    "function_signature": "def count_subset_sum(values, target):",
    "instruction": "Implement count_subset_sum(values, target).",
    "constraints": [
      "Values are non-negative integers",
      "Each element can be used at most once"
    ],
    "io_examples": [
      {
        "input": [
          [
            1,
            2,
            3,
            3
          ],
          6
        ],
        "output": 3
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def count_subset_sum(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "count_subset_sum",
      "examples": [
        {
          "args": [
            [
              1,
              2,
              3,
              3
            ],
            6
          ],
          "expected": 3
        },
        {
          "args": [
            [
              2,
              4,
              6,
              10
            ],
            16
          ],
          "expected": 2
        },
        {
          "args": [
            [
              1,
              1,
              1
            ],
            2
          ],
          "expected": 3
        }
      ]
    }
  },
  {
    "id": "029",
    "tier": 4,
    "description": "K closest points to origin.",
    "problem": "Return k points closest to origin by Euclidean distance; break ties by x then y for determinism.",
    "function_signature": "def k_closest_points(points, k):",
    "instruction": "Implement k_closest_points(points, k).",
    "constraints": [
      "Return points sorted by deterministic ranking",
      "Input points are [x, y]"
    ],
    "io_examples": [
      {
        "input": [
          [
            [
              1,
              3
            ],
            [
              -2,
              2
            ],
            [
              2,
              -2
            ]
          ],
          2
        ],
        "output": [
          [
            -2,
            2
          ],
          [
            2,
            -2
          ]
        ]
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def k_closest_points(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "k_closest_points",
      "examples": [
        {
          "args": [
            [
              [
                1,
                3
              ],
              [
                -2,
                2
              ],
              [
                2,
                -2
              ]
            ],
            2
          ],
          "expected": [
            [
              -2,
              2
            ],
            [
              2,
              -2
            ]
          ]
        },
        {
          "args": [
            [
              [
                3,
                3
              ],
              [
                5,
                -1
              ],
              [
                -2,
                4
              ]
            ],
            2
          ],
          "expected": [
            [
              3,
              3
            ],
            [
              -2,
              4
            ]
          ]
        }
      ]
    }
  },
  {
    "id": "030",
    "tier": 4,
    "description": "Evaluate Reverse Polish Notation expression.",
    "problem": "Evaluate a tokenized Reverse Polish Notation expression and return the integer result.",
    "function_signature": "def eval_rpn(tokens):",
    "instruction": "Implement eval_rpn(tokens). Treat token as operator only when token is one of + - * /. Otherwise parse token as signed integer (including negatives like -11).",
    "constraints": [
      "Operators are +, -, *, /",
      "Operands may be signed integers as strings",
      "Division truncates toward zero"
    ],
    "io_examples": [
      {
        "input": [
          [
            "2",
            "1",
            "+",
            "3",
            "*"
          ]
        ],
        "output": 9
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def eval_rpn(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "eval_rpn",
      "examples": [
        {
          "args": [
            [
              "2",
              "1",
              "+",
              "3",
              "*"
            ]
          ],
          "expected": 9
        },
        {
          "args": [
            [
              "4",
              "13",
              "5",
              "/",
              "+"
            ]
          ],
          "expected": 6
        },
        {
          "args": [
            [
              "10",
              "6",
              "9",
              "3",
              "+",
              "-11",
              "*",
              "/",
              "*",
              "17",
              "+",
              "5",
              "+"
            ]
          ],
          "expected": 22
        },
        {
          "args": [
            [
              "-2",
              "3",
              "/"
            ]
          ],
          "expected": 0
        }
      ]
    }
  },
  {
    "id": "031",
    "tier": 5,
    "description": "Daily temperatures wait count.",
    "problem": "For each day, return number of days until a warmer temperature, or 0 if none.",
    "function_signature": "def daily_temperatures(temps):",
    "instruction": "Implement daily_temperatures(temps).",
    "constraints": [
      "Return list of same length",
      "Deterministic monotonic-stack behavior"
    ],
    "io_examples": [
      {
        "input": [
          [
            73,
            74,
            75,
            71,
            69,
            72,
            76,
            73
          ]
        ],
        "output": [
          1,
          1,
          4,
          2,
          1,
          1,
          0,
          0
        ]
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def daily_temperatures(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "daily_temperatures",
      "examples": [
        {
          "args": [
            [
              73,
              74,
              75,
              71,
              69,
              72,
              76,
              73
            ]
          ],
          "expected": [
            1,
            1,
            4,
            2,
            1,
            1,
            0,
            0
          ]
        },
        {
          "args": [
            [
              30,
              40,
              50,
              60
            ]
          ],
          "expected": [
            1,
            1,
            1,
            0
          ]
        },
        {
          "args": [
            [
              30,
              60,
              90
            ]
          ],
          "expected": [
            1,
            1,
            0
          ]
        }
      ]
    }
  },
  {
    "id": "032",
    "tier": 5,
    "description": "Minimum meeting rooms.",
    "problem": "Given meeting intervals [start, end], return the minimum number of rooms required.",
    "function_signature": "def min_meeting_rooms(intervals):",
    "instruction": "Implement min_meeting_rooms(intervals).",
    "constraints": [
      "Intervals are half-open by end time semantics",
      "Return integer count"
    ],
    "io_examples": [
      {
        "input": [
          [
            [
              0,
              30
            ],
            [
              5,
              10
            ],
            [
              15,
              20
            ]
          ]
        ],
        "output": 2
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def min_meeting_rooms(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "min_meeting_rooms",
      "examples": [
        {
          "args": [
            [
              [
                0,
                30
              ],
              [
                5,
                10
              ],
              [
                15,
                20
              ]
            ]
          ],
          "expected": 2
        },
        {
          "args": [
            [
              [
                7,
                10
              ],
              [
                2,
                4
              ]
            ]
          ],
          "expected": 1
        },
        {
          "args": [
            [
              [
                1,
                5
              ],
              [
                2,
                3
              ],
              [
                3,
                6
              ]
            ]
          ],
          "expected": 2
        }
      ]
    }
  },
  {
    "id": "033",
    "tier": 5,
    "description": "Top-k frequent elements with deterministic tie-breaks.",
    "problem": "Return k most frequent values sorted by frequency descending and value ascending for ties.",
    "function_signature": "def top_k_frequent(values, k):",
    "instruction": "Implement top_k_frequent(values, k).",
    "constraints": [
      "Deterministic ordering is required",
      "k >= 1"
    ],
    "io_examples": [
      {
        "input": [
          [
            1,
            1,
            1,
            2,
            2,
            3
          ],
          2
        ],
        "output": [
          1,
          2
        ]
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def top_k_frequent(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "top_k_frequent",
      "examples": [
        {
          "args": [
            [
              1,
              1,
              1,
              2,
              2,
              3
            ],
            2
          ],
          "expected": [
            1,
            2
          ]
        },
        {
          "args": [
            [
              4,
              4,
              1,
              1,
              2,
              2
            ],
            2
          ],
          "expected": [
            1,
            2
          ]
        },
        {
          "args": [
            [
              5
            ],
            1
          ],
          "expected": [
            5
          ]
        }
      ]
    }
  },
  {
    "id": "034",
    "tier": 5,
    "description": "LRU cache trace simulator.",
    "problem": "Simulate an LRU cache and return outputs for each get operation in order.",
    "function_signature": "def lru_trace(capacity, operations):",
    "instruction": "Implement lru_trace(capacity, operations). For get: if key exists, append value and mark key as most recently used; if missing append -1. For put: insert/update key, mark most recently used, and evict least recently used when over capacity.",
    "constraints": [
      "Operation format: [op, key, value?] where op is put or get",
      "Do not mutate a key and then pop it again during get",
      "For each get append returned value or -1 to result list"
    ],
    "io_examples": [
      {
        "input": [
          2,
          [
            [
              "put",
              1,
              1
            ],
            [
              "put",
              2,
              2
            ],
            [
              "get",
              1
            ],
            [
              "put",
              3,
              3
            ],
            [
              "get",
              2
            ],
            [
              "put",
              4,
              4
            ],
            [
              "get",
              1
            ],
            [
              "get",
              3
            ],
            [
              "get",
              4
            ]
          ]
        ],
        "output": [
          1,
          -1,
          -1,
          3,
          4
        ]
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def lru_trace(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "lru_trace",
      "examples": [
        {
          "args": [
            2,
            [
              [
                "put",
                1,
                1
              ],
              [
                "put",
                2,
                2
              ],
              [
                "get",
                1
              ],
              [
                "put",
                3,
                3
              ],
              [
                "get",
                2
              ],
              [
                "put",
                4,
                4
              ],
              [
                "get",
                1
              ],
              [
                "get",
                3
              ],
              [
                "get",
                4
              ]
            ]
          ],
          "expected": [
            1,
            -1,
            -1,
            3,
            4
          ]
        },
        {
          "args": [
            1,
            [
              [
                "put",
                1,
                10
              ],
              [
                "get",
                1
              ],
              [
                "put",
                2,
                20
              ],
              [
                "get",
                1
              ],
              [
                "get",
                2
              ]
            ]
          ],
          "expected": [
            10,
            -1,
            20
          ]
        },
        {
          "args": [
            2,
            [
              [
                "put",
                2,
                1
              ],
              [
                "put",
                2,
                2
              ],
              [
                "get",
                2
              ]
            ]
          ],
          "expected": [
            2
          ]
        }
      ]
    }
  },
  {
    "id": "035",
    "tier": 5,
    "description": "Shortest path in binary matrix.",
    "problem": "Return shortest path length from top-left to bottom-right in binary grid moving 8 directions, where 0 is open and 1 is blocked.",
    "function_signature": "def shortest_path_binary_matrix(grid):",
    "instruction": "Implement shortest_path_binary_matrix(grid).",
    "constraints": [
      "Return -1 if no path exists",
      "Path length counts visited cells"
    ],
    "io_examples": [
      {
        "input": [
          [
            [
              0,
              1
            ],
            [
              1,
              0
            ]
          ]
        ],
        "output": 2
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def shortest_path_binary_matrix(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "shortest_path_binary_matrix",
      "examples": [
        {
          "args": [
            [
              [
                0,
                1
              ],
              [
                1,
                0
              ]
            ]
          ],
          "expected": 2
        },
        {
          "args": [
            [
              [
                0,
                0,
                0
              ],
              [
                1,
                1,
                0
              ],
              [
                1,
                1,
                0
              ]
            ]
          ],
          "expected": 4
        },
        {
          "args": [
            [
              [
                1,
                0
              ],
              [
                0,
                0
              ]
            ]
          ],
          "expected": -1
        }
      ]
    }
  },
  {
    "id": "036",
    "tier": 5,
    "description": "Word ladder length.",
    "problem": "Return length of shortest transformation sequence from begin_word to end_word changing one letter at a time with intermediate words in dictionary.",
    "function_signature": "def word_ladder_length(begin_word, end_word, word_list):",
    "instruction": "Implement word_ladder_length(begin_word, end_word, word_list).",
    "constraints": [
      "Each transformed word must be in word_list",
      "Return 0 if impossible"
    ],
    "io_examples": [
      {
        "input": [
          "hit",
          "cog",
          [
            "hot",
            "dot",
            "dog",
            "lot",
            "log",
            "cog"
          ]
        ],
        "output": 5
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def word_ladder_length(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "word_ladder_length",
      "examples": [
        {
          "args": [
            "hit",
            "cog",
            [
              "hot",
              "dot",
              "dog",
              "lot",
              "log",
              "cog"
            ]
          ],
          "expected": 5
        },
        {
          "args": [
            "hit",
            "cog",
            [
              "hot",
              "dot",
              "dog",
              "lot",
              "log"
            ]
          ],
          "expected": 0
        }
      ]
    }
  },
  {
    "id": "037",
    "tier": 5,
    "description": "Dijkstra shortest path cost.",
    "problem": "Given directed weighted edges, return the minimum path cost from start to end, or -1 if unreachable.",
    "function_signature": "def dijkstra_shortest_path(n, edges, start, end):",
    "instruction": "Implement dijkstra_shortest_path(n, edges, start, end).",
    "constraints": [
      "Nodes are 0..n-1",
      "Edges format [u, v, w] with w >= 0"
    ],
    "io_examples": [
      {
        "input": [
          5,
          [
            [
              0,
              1,
              2
            ],
            [
              1,
              2,
              3
            ],
            [
              0,
              3,
              6
            ],
            [
              3,
              4,
              2
            ],
            [
              2,
              4,
              1
            ]
          ],
          0,
          4
        ],
        "output": 6
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def dijkstra_shortest_path(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "dijkstra_shortest_path",
      "examples": [
        {
          "args": [
            5,
            [
              [
                0,
                1,
                2
              ],
              [
                1,
                2,
                3
              ],
              [
                0,
                3,
                6
              ],
              [
                3,
                4,
                2
              ],
              [
                2,
                4,
                1
              ]
            ],
            0,
            4
          ],
          "expected": 6
        },
        {
          "args": [
            3,
            [
              [
                0,
                1,
                5
              ]
            ],
            0,
            2
          ],
          "expected": -1
        }
      ]
    }
  },
  {
    "id": "038",
    "tier": 5,
    "description": "Merge k sorted lists.",
    "problem": "Merge k sorted integer lists into one sorted list.",
    "function_signature": "def merge_k_sorted(lists):",
    "instruction": "Implement merge_k_sorted(lists).",
    "constraints": [
      "Each input list is sorted ascending",
      "Return sorted merged list"
    ],
    "io_examples": [
      {
        "input": [
          [
            [
              1,
              4,
              5
            ],
            [
              1,
              3,
              4
            ],
            [
              2,
              6
            ]
          ]
        ],
        "output": [
          1,
          1,
          2,
          3,
          4,
          4,
          5,
          6
        ]
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def merge_k_sorted(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "merge_k_sorted",
      "examples": [
        {
          "args": [
            [
              [
                1,
                4,
                5
              ],
              [
                1,
                3,
                4
              ],
              [
                2,
                6
              ]
            ]
          ],
          "expected": [
            1,
            1,
            2,
            3,
            4,
            4,
            5,
            6
          ]
        },
        {
          "args": [
            [
              [],
              [
                0
              ],
              [
                2,
                2
              ]
            ]
          ],
          "expected": [
            0,
            2,
            2
          ]
        }
      ]
    }
  },
  {
    "id": "039",
    "tier": 6,
    "description": "Flatten nested JSON object.",
    "problem": "Flatten nested dict/list structure into a dictionary of dotted keys. Use list indices in brackets, e.g. a.b[0].c.",
    "function_signature": "def flatten_json(payload):",
    "instruction": "Implement flatten_json(payload).",
    "constraints": [
      "Return a flat dict mapping string keys to scalar values",
      "Use deterministic key naming"
    ],
    "io_examples": [
      {
        "input": [
          {
            "a": {
              "b": [
                1,
                {
                  "c": 2
                }
              ]
            },
            "d": 3
          }
        ],
        "output": {
          "a.b[0]": 1,
          "a.b[1].c": 2,
          "d": 3
        }
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def flatten_json(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "flatten_json",
      "examples": [
        {
          "args": [
            {
              "a": {
                "b": [
                  1,
                  {
                    "c": 2
                  }
                ]
              },
              "d": 3
            }
          ],
          "expected": {
            "a.b[0]": 1,
            "a.b[1].c": 2,
            "d": 3
          }
        },
        {
          "args": [
            {
              "x": [
                10,
                20
              ],
              "y": {
                "z": true
              }
            }
          ],
          "expected": {
            "x[0]": 10,
            "x[1]": 20,
            "y.z": true
          }
        }
      ]
    }
  },
  {
    "id": "040",
    "tier": 6,
    "description": "Sudoku board validator.",
    "problem": "Return True if a 9x9 Sudoku board is valid (rows, columns, and 3x3 boxes contain no duplicate digits 1-9 ignoring '.').",
    "function_signature": "def is_valid_sudoku(board):",
    "instruction": "Implement is_valid_sudoku(board).",
    "constraints": [
      "Board is list of 9 lists of 9 strings",
      "Only characters '1'-'9' and '.' appear"
    ],
    "io_examples": [
      {
        "input": [
          [
            [
              "5",
              "3",
              ".",
              ".",
              "7",
              ".",
              ".",
              ".",
              "."
            ],
            [
              "6",
              ".",
              ".",
              "1",
              "9",
              "5",
              ".",
              ".",
              "."
            ],
            [
              ".",
              "9",
              "8",
              ".",
              ".",
              ".",
              ".",
              "6",
              "."
            ],
            [
              "8",
              ".",
              ".",
              ".",
              "6",
              ".",
              ".",
              ".",
              "3"
            ],
            [
              "4",
              ".",
              ".",
              "8",
              ".",
              "3",
              ".",
              ".",
              "1"
            ],
            [
              "7",
              ".",
              ".",
              ".",
              "2",
              ".",
              ".",
              ".",
              "6"
            ],
            [
              ".",
              "6",
              ".",
              ".",
              ".",
              ".",
              "2",
              "8",
              "."
            ],
            [
              ".",
              ".",
              ".",
              "4",
              "1",
              "9",
              ".",
              ".",
              "5"
            ],
            [
              ".",
              ".",
              ".",
              ".",
              "8",
              ".",
              ".",
              "7",
              "9"
            ]
          ]
        ],
        "output": true
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def is_valid_sudoku(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "is_valid_sudoku",
      "examples": [
        {
          "args": [
            [
              [
                "5",
                "3",
                ".",
                ".",
                "7",
                ".",
                ".",
                ".",
                "."
              ],
              [
                "6",
                ".",
                ".",
                "1",
                "9",
                "5",
                ".",
                ".",
                "."
              ],
              [
                ".",
                "9",
                "8",
                ".",
                ".",
                ".",
                ".",
                "6",
                "."
              ],
              [
                "8",
                ".",
                ".",
                ".",
                "6",
                ".",
                ".",
                ".",
                "3"
              ],
              [
                "4",
                ".",
                ".",
                "8",
                ".",
                "3",
                ".",
                ".",
                "1"
              ],
              [
                "7",
                ".",
                ".",
                ".",
                "2",
                ".",
                ".",
                ".",
                "6"
              ],
              [
                ".",
                "6",
                ".",
                ".",
                ".",
                ".",
                "2",
                "8",
                "."
              ],
              [
                ".",
                ".",
                ".",
                "4",
                "1",
                "9",
                ".",
                ".",
                "5"
              ],
              [
                ".",
                ".",
                ".",
                ".",
                "8",
                ".",
                ".",
                "7",
                "9"
              ]
            ]
          ],
          "expected": true
        },
        {
          "args": [
            [
              [
                "8",
                "3",
                ".",
                ".",
                "7",
                ".",
                ".",
                ".",
                "."
              ],
              [
                "6",
                ".",
                ".",
                "1",
                "9",
                "5",
                ".",
                ".",
                "."
              ],
              [
                ".",
                "9",
                "8",
                ".",
                ".",
                ".",
                ".",
                "6",
                "."
              ],
              [
                "8",
                ".",
                ".",
                ".",
                "6",
                ".",
                ".",
                ".",
                "3"
              ],
              [
                "4",
                ".",
                ".",
                "8",
                ".",
                "3",
                ".",
                ".",
                "1"
              ],
              [
                "7",
                ".",
                ".",
                ".",
                "2",
                ".",
                ".",
                ".",
                "6"
              ],
              [
                ".",
                "6",
                ".",
                ".",
                ".",
                ".",
                "2",
                "8",
                "."
              ],
              [
                ".",
                ".",
                ".",
                "4",
                "1",
                "9",
                ".",
                ".",
                "5"
              ],
              [
                ".",
                ".",
                ".",
                ".",
                "8",
                ".",
                ".",
                "7",
                "9"
              ]
            ]
          ],
          "expected": false
        }
      ]
    }
  },
  {
    "id": "041",
    "tier": 6,
    "description": "Find first substring occurrence using exact match.",
    "problem": "Return the first index where pattern appears in text, or -1 if absent.",
    "function_signature": "def first_substring_index(text, pattern):",
    "instruction": "Implement first_substring_index(text, pattern).",
    "constraints": [
      "Case-sensitive",
      "Return 0 when pattern is empty"
    ],
    "io_examples": [
      {
        "input": [
          "hello",
          "ll"
        ],
        "output": 2
      },
      {
        "input": [
          "aaaaa",
          "bba"
        ],
        "output": -1
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def first_substring_index(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "first_substring_index",
      "examples": [
        {
          "args": [
            "hello",
            "ll"
          ],
          "expected": 2
        },
        {
          "args": [
            "aaaaa",
            "bba"
          ],
          "expected": -1
        },
        {
          "args": [
            "abc",
            ""
          ],
          "expected": 0
        }
      ]
    }
  },
  {
    "id": "042",
    "tier": 6,
    "description": "Levenshtein edit distance.",
    "problem": "Return minimum number of insertions, deletions, and substitutions to convert a into b.",
    "function_signature": "def edit_distance(a, b):",
    "instruction": "Implement edit_distance(a, b).",
    "constraints": [
      "Return integer distance",
      "Allow empty strings"
    ],
    "io_examples": [
      {
        "input": [
          "kitten",
          "sitting"
        ],
        "output": 3
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def edit_distance(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "edit_distance",
      "examples": [
        {
          "args": [
            "kitten",
            "sitting"
          ],
          "expected": 3
        },
        {
          "args": [
            "",
            "abc"
          ],
          "expected": 3
        },
        {
          "args": [
            "abc",
            "abc"
          ],
          "expected": 0
        }
      ]
    }
  },
  {
    "id": "043",
    "tier": 6,
    "description": "Largest rectangle in histogram.",
    "problem": "Given bar heights, return the largest rectangular area in the histogram.",
    "function_signature": "def largest_histogram_area(heights):",
    "instruction": "Implement largest_histogram_area(heights).",
    "constraints": [
      "Heights are non-negative integers"
    ],
    "io_examples": [
      {
        "input": [
          [
            2,
            1,
            5,
            6,
            2,
            3
          ]
        ],
        "output": 10
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def largest_histogram_area(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "largest_histogram_area",
      "examples": [
        {
          "args": [
            [
              2,
              1,
              5,
              6,
              2,
              3
            ]
          ],
          "expected": 10
        },
        {
          "args": [
            [
              2,
              4
            ]
          ],
          "expected": 4
        },
        {
          "args": [
            []
          ],
          "expected": 0
        }
      ]
    }
  },
  {
    "id": "044",
    "tier": 6,
    "description": "Trap rain water.",
    "problem": "Given elevation map heights, return total trapped rain water.",
    "function_signature": "def trap_rain_water(heights):",
    "instruction": "Implement trap_rain_water(heights).",
    "constraints": [
      "Heights are non-negative integers"
    ],
    "io_examples": [
      {
        "input": [
          [
            0,
            1,
            0,
            2,
            1,
            0,
            1,
            3,
            2,
            1,
            2,
            1
          ]
        ],
        "output": 6
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def trap_rain_water(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "trap_rain_water",
      "examples": [
        {
          "args": [
            [
              0,
              1,
              0,
              2,
              1,
              0,
              1,
              3,
              2,
              1,
              2,
              1
            ]
          ],
          "expected": 6
        },
        {
          "args": [
            [
              4,
              2,
              0,
              3,
              2,
              5
            ]
          ],
          "expected": 9
        },
        {
          "args": [
            []
          ],
          "expected": 0
        }
      ]
    }
  },
  {
    "id": "045",
    "tier": 6,
    "description": "Course schedule feasibility.",
    "problem": "Given prerequisites [a,b] meaning b before a, return True if all courses can be finished.",
    "function_signature": "def can_finish_courses(num_courses, prerequisites):",
    "instruction": "Implement can_finish_courses(num_courses, prerequisites).",
    "constraints": [
      "Detect cycles in directed graph"
    ],
    "io_examples": [
      {
        "input": [
          2,
          [
            [
              1,
              0
            ]
          ]
        ],
        "output": true
      },
      {
        "input": [
          2,
          [
            [
              1,
              0
            ],
            [
              0,
              1
            ]
          ]
        ],
        "output": false
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def can_finish_courses(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "can_finish_courses",
      "examples": [
        {
          "args": [
            2,
            [
              [
                1,
                0
              ]
            ]
          ],
          "expected": true
        },
        {
          "args": [
            2,
            [
              [
                1,
                0
              ],
              [
                0,
                1
              ]
            ]
          ],
          "expected": false
        },
        {
          "args": [
            3,
            []
          ],
          "expected": true
        }
      ]
    }
  },
  {
    "id": "046",
    "tier": 6,
    "description": "Topological order with deterministic tie-break.",
    "problem": "Return a valid topological ordering for courses. If multiple nodes are available, pick the smallest index first. Return [] if cycle exists.",
    "function_signature": "def course_order(num_courses, prerequisites):",
    "instruction": "Implement course_order(num_courses, prerequisites) using Kahn's algorithm. Always choose the smallest available course index first to guarantee deterministic output.",
    "constraints": [
      "Deterministic ordering required",
      "Use smallest-index tie-break when multiple nodes have indegree 0",
      "Return empty list on cycle"
    ],
    "io_examples": [
      {
        "input": [
          4,
          [
            [
              1,
              0
            ],
            [
              2,
              0
            ],
            [
              3,
              1
            ],
            [
              3,
              2
            ]
          ]
        ],
        "output": [
          0,
          1,
          2,
          3
        ]
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def course_order(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "course_order",
      "examples": [
        {
          "args": [
            4,
            [
              [
                1,
                0
              ],
              [
                2,
                0
              ],
              [
                3,
                1
              ],
              [
                3,
                2
              ]
            ]
          ],
          "expected": [
            0,
            1,
            2,
            3
          ]
        },
        {
          "args": [
            6,
            [
              [
                2,
                1
              ],
              [
                3,
                1
              ],
              [
                4,
                2
              ],
              [
                4,
                3
              ],
              [
                5,
                4
              ]
            ]
          ],
          "expected": [
            0,
            1,
            2,
            3,
            4,
            5
          ]
        },
        {
          "args": [
            2,
            [
              [
                1,
                0
              ],
              [
                0,
                1
              ]
            ]
          ],
          "expected": []
        },
        {
          "args": [
            3,
            []
          ],
          "expected": [
            0,
            1,
            2
          ]
        }
      ]
    }
  },
  {
    "id": "047",
    "tier": 6,
    "description": "Word break feasibility.",
    "problem": "Return True if s can be segmented into one or more dictionary words.",
    "function_signature": "def word_break_possible(s, word_dict):",
    "instruction": "Implement word_break_possible(s, word_dict).",
    "constraints": [
      "word_dict is list of strings"
    ],
    "io_examples": [
      {
        "input": [
          "leetcode",
          [
            "leet",
            "code"
          ]
        ],
        "output": true
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def word_break_possible(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "word_break_possible",
      "examples": [
        {
          "args": [
            "leetcode",
            [
              "leet",
              "code"
            ]
          ],
          "expected": true
        },
        {
          "args": [
            "applepenapple",
            [
              "apple",
              "pen"
            ]
          ],
          "expected": true
        },
        {
          "args": [
            "catsandog",
            [
              "cats",
              "dog",
              "sand",
              "and",
              "cat"
            ]
          ],
          "expected": false
        }
      ]
    }
  },
  {
    "id": "048",
    "tier": 6,
    "description": "Insert and merge interval.",
    "problem": "Insert new interval into sorted non-overlapping intervals and merge if needed.",
    "function_signature": "def insert_interval(intervals, new_interval):",
    "instruction": "Implement insert_interval(intervals, new_interval).",
    "constraints": [
      "Return intervals sorted by start"
    ],
    "io_examples": [
      {
        "input": [
          [
            [
              1,
              3
            ],
            [
              6,
              9
            ]
          ],
          [
            2,
            5
          ]
        ],
        "output": [
          [
            1,
            5
          ],
          [
            6,
            9
          ]
        ]
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def insert_interval(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "insert_interval",
      "examples": [
        {
          "args": [
            [
              [
                1,
                3
              ],
              [
                6,
                9
              ]
            ],
            [
              2,
              5
            ]
          ],
          "expected": [
            [
              1,
              5
            ],
            [
              6,
              9
            ]
          ]
        },
        {
          "args": [
            [
              [
                1,
                2
              ],
              [
                3,
                5
              ],
              [
                6,
                7
              ],
              [
                8,
                10
              ],
              [
                12,
                16
              ]
            ],
            [
              4,
              8
            ]
          ],
          "expected": [
            [
              1,
              2
            ],
            [
              3,
              10
            ],
            [
              12,
              16
            ]
          ]
        }
      ]
    }
  },
  {
    "id": "049",
    "tier": 6,
    "description": "Median of two sorted arrays.",
    "problem": "Return median value of two sorted arrays as float when needed.",
    "function_signature": "def median_two_sorted_arrays(a, b):",
    "instruction": "Implement median_two_sorted_arrays(a, b).",
    "constraints": [
      "Arrays are sorted ascending",
      "Total length >= 1"
    ],
    "io_examples": [
      {
        "input": [
          [
            1,
            3
          ],
          [
            2
          ]
        ],
        "output": 2.0
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def median_two_sorted_arrays(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "median_two_sorted_arrays",
      "examples": [
        {
          "args": [
            [
              1,
              3
            ],
            [
              2
            ]
          ],
          "expected": 2.0
        },
        {
          "args": [
            [
              1,
              2
            ],
            [
              3,
              4
            ]
          ],
          "expected": 2.5
        },
        {
          "args": [
            [],
            [
              1
            ]
          ],
          "expected": 1.0
        }
      ]
    }
  },
  {
    "id": "050",
    "tier": 5,
    "description": "Spiral matrix order.",
    "problem": "Return all matrix elements in spiral order.",
    "function_signature": "def spiral_order(matrix):",
    "instruction": "Implement spiral_order(matrix).",
    "constraints": [
      "Return list",
      "Handle empty matrix"
    ],
    "io_examples": [
      {
        "input": [
          [
            [
              1,
              2,
              3
            ],
            [
              4,
              5,
              6
            ],
            [
              7,
              8,
              9
            ]
          ]
        ],
        "output": [
          1,
          2,
          3,
          6,
          9,
          8,
          7,
          4,
          5
        ]
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def spiral_order(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "spiral_order",
      "examples": [
        {
          "args": [
            [
              [
                1,
                2,
                3
              ],
              [
                4,
                5,
                6
              ],
              [
                7,
                8,
                9
              ]
            ]
          ],
          "expected": [
            1,
            2,
            3,
            6,
            9,
            8,
            7,
            4,
            5
          ]
        },
        {
          "args": [
            [
              [
                1,
                2,
                3,
                4
              ],
              [
                5,
                6,
                7,
                8
              ],
              [
                9,
                10,
                11,
                12
              ]
            ]
          ],
          "expected": [
            1,
            2,
            3,
            4,
            8,
            12,
            11,
            10,
            9,
            5,
            6,
            7
          ]
        }
      ]
    }
  },
  {
    "id": "051",
    "tier": 5,
    "description": "Longest increasing subsequence length.",
    "problem": "Return the length of the longest strictly increasing subsequence.",
    "function_signature": "def lis_length(values):",
    "instruction": "Implement lis_length(values).",
    "constraints": [
      "Return integer length"
    ],
    "io_examples": [
      {
        "input": [
          [
            10,
            9,
            2,
            5,
            3,
            7,
            101,
            18
          ]
        ],
        "output": 4
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def lis_length(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "lis_length",
      "examples": [
        {
          "args": [
            [
              10,
              9,
              2,
              5,
              3,
              7,
              101,
              18
            ]
          ],
          "expected": 4
        },
        {
          "args": [
            [
              0,
              1,
              0,
              3,
              2,
              3
            ]
          ],
          "expected": 4
        },
        {
          "args": [
            [
              7,
              7,
              7,
              7
            ]
          ],
          "expected": 1
        }
      ]
    }
  },
  {
    "id": "052",
    "tier": 5,
    "description": "Maximum subarray sum.",
    "problem": "Return maximum possible sum of a contiguous subarray.",
    "function_signature": "def max_subarray_sum(values):",
    "instruction": "Implement max_subarray_sum(values).",
    "constraints": [
      "Input non-empty"
    ],
    "io_examples": [
      {
        "input": [
          [
            -2,
            1,
            -3,
            4,
            -1,
            2,
            1,
            -5,
            4
          ]
        ],
        "output": 6
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def max_subarray_sum(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "max_subarray_sum",
      "examples": [
        {
          "args": [
            [
              -2,
              1,
              -3,
              4,
              -1,
              2,
              1,
              -5,
              4
            ]
          ],
          "expected": 6
        },
        {
          "args": [
            [
              1
            ]
          ],
          "expected": 1
        },
        {
          "args": [
            [
              -1,
              -2,
              -3
            ]
          ],
          "expected": -1
        }
      ]
    }
  },
  {
    "id": "053",
    "tier": 5,
    "description": "Connected components count in undirected graph.",
    "problem": "Given n nodes and undirected edges, return number of connected components.",
    "function_signature": "def connected_components_count(n, edges):",
    "instruction": "Implement connected_components_count(n, edges).",
    "constraints": [
      "Nodes are 0..n-1"
    ],
    "io_examples": [
      {
        "input": [
          5,
          [
            [
              0,
              1
            ],
            [
              1,
              2
            ],
            [
              3,
              4
            ]
          ]
        ],
        "output": 2
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def connected_components_count(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "connected_components_count",
      "examples": [
        {
          "args": [
            5,
            [
              [
                0,
                1
              ],
              [
                1,
                2
              ],
              [
                3,
                4
              ]
            ]
          ],
          "expected": 2
        },
        {
          "args": [
            5,
            [
              [
                0,
                1
              ],
              [
                1,
                2
              ],
              [
                2,
                3
              ],
              [
                3,
                4
              ]
            ]
          ],
          "expected": 1
        },
        {
          "args": [
            4,
            []
          ],
          "expected": 4
        }
      ]
    }
  },
  {
    "id": "054",
    "tier": 5,
    "description": "Count islands in grid.",
    "problem": "Return number of islands in binary grid where 1 is land and 0 is water (4-direction connectivity).",
    "function_signature": "def count_islands(grid):",
    "instruction": "Implement count_islands(grid).",
    "constraints": [
      "Do not mutate caller-visible structure unexpectedly"
    ],
    "io_examples": [
      {
        "input": [
          [
            [
              "1",
              "1",
              "0",
              "0"
            ],
            [
              "1",
              "1",
              "0",
              "0"
            ],
            [
              "0",
              "0",
              "1",
              "0"
            ],
            [
              "0",
              "0",
              "0",
              "1"
            ]
          ]
        ],
        "output": 3
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def count_islands(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "count_islands",
      "examples": [
        {
          "args": [
            [
              [
                "1",
                "1",
                "0",
                "0"
              ],
              [
                "1",
                "1",
                "0",
                "0"
              ],
              [
                "0",
                "0",
                "1",
                "0"
              ],
              [
                "0",
                "0",
                "0",
                "1"
              ]
            ]
          ],
          "expected": 3
        },
        {
          "args": [
            [
              [
                "1",
                "1",
                "1"
              ],
              [
                "0",
                "1",
                "0"
              ],
              [
                "1",
                "1",
                "1"
              ]
            ]
          ],
          "expected": 1
        }
      ]
    }
  },
  {
    "id": "055",
    "tier": 6,
    "description": "Shortest path in weighted DAG.",
    "problem": "Given a DAG with weighted directed edges [u,v,w], return shortest path cost from start to end or -1 if unreachable.",
    "function_signature": "def dag_shortest_path(n, edges, start, end):",
    "instruction": "Implement dag_shortest_path(n, edges, start, end).",
    "constraints": [
      "Graph is acyclic",
      "Weights may be negative or positive"
    ],
    "io_examples": [
      {
        "input": [
          6,
          [
            [
              0,
              1,
              5
            ],
            [
              0,
              2,
              3
            ],
            [
              1,
              3,
              6
            ],
            [
              1,
              2,
              2
            ],
            [
              2,
              4,
              4
            ],
            [
              2,
              5,
              2
            ],
            [
              2,
              3,
              7
            ],
            [
              3,
              4,
              -1
            ],
            [
              4,
              5,
              -2
            ]
          ],
          1,
          5
        ],
        "output": 3
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def dag_shortest_path(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "dag_shortest_path",
      "examples": [
        {
          "args": [
            6,
            [
              [
                0,
                1,
                5
              ],
              [
                0,
                2,
                3
              ],
              [
                1,
                3,
                6
              ],
              [
                1,
                2,
                2
              ],
              [
                2,
                4,
                4
              ],
              [
                2,
                5,
                2
              ],
              [
                2,
                3,
                7
              ],
              [
                3,
                4,
                -1
              ],
              [
                4,
                5,
                -2
              ]
            ],
            1,
            5
          ],
          "expected": 3
        },
        {
          "args": [
            3,
            [
              [
                0,
                1,
                1
              ]
            ],
            0,
            2
          ],
          "expected": -1
        }
      ]
    }
  },
  {
    "id": "056",
    "tier": 6,
    "description": "0/1 knapsack max value.",
    "problem": "Given weights, values, and capacity, return maximum obtainable value.",
    "function_signature": "def knapsack_01(weights, values, capacity):",
    "instruction": "Implement knapsack_01(weights, values, capacity).",
    "constraints": [
      "Each item can be used at most once"
    ],
    "io_examples": [
      {
        "input": [
          [
            1,
            3,
            4,
            5
          ],
          [
            1,
            4,
            5,
            7
          ],
          7
        ],
        "output": 9
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def knapsack_01(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "knapsack_01",
      "examples": [
        {
          "args": [
            [
              1,
              3,
              4,
              5
            ],
            [
              1,
              4,
              5,
              7
            ],
            7
          ],
          "expected": 9
        },
        {
          "args": [
            [
              2,
              3,
              4
            ],
            [
              4,
              5,
              6
            ],
            5
          ],
          "expected": 9
        },
        {
          "args": [
            [],
            [],
            10
          ],
          "expected": 0
        }
      ]
    }
  },
  {
    "id": "057",
    "tier": 6,
    "description": "Longest common subsequence length.",
    "problem": "Return length of the longest common subsequence between two strings.",
    "function_signature": "def lcs_length(a, b):",
    "instruction": "Implement lcs_length(a, b).",
    "constraints": [
      "Return integer length"
    ],
    "io_examples": [
      {
        "input": [
          "abcde",
          "ace"
        ],
        "output": 3
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def lcs_length(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "lcs_length",
      "examples": [
        {
          "args": [
            "abcde",
            "ace"
          ],
          "expected": 3
        },
        {
          "args": [
            "abc",
            "abc"
          ],
          "expected": 3
        },
        {
          "args": [
            "abc",
            "def"
          ],
          "expected": 0
        }
      ]
    }
  },
  {
    "id": "058",
    "tier": 6,
    "description": "Find redundant connection in undirected graph.",
    "problem": "Given edges for a tree plus one extra edge, return the redundant edge that creates a cycle. If multiple, return the last one in input that forms cycle.",
    "function_signature": "def redundant_connection(edges):",
    "instruction": "Implement redundant_connection(edges).",
    "constraints": [
      "Edges are [u,v] with 1-based node labels"
    ],
    "io_examples": [
      {
        "input": [
          [
            [
              1,
              2
            ],
            [
              1,
              3
            ],
            [
              2,
              3
            ]
          ]
        ],
        "output": [
          2,
          3
        ]
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def redundant_connection(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "redundant_connection",
      "examples": [
        {
          "args": [
            [
              [
                1,
                2
              ],
              [
                1,
                3
              ],
              [
                2,
                3
              ]
            ]
          ],
          "expected": [
            2,
            3
          ]
        },
        {
          "args": [
            [
              [
                1,
                2
              ],
              [
                2,
                3
              ],
              [
                3,
                4
              ],
              [
                1,
                4
              ],
              [
                1,
                5
              ]
            ]
          ],
          "expected": [
            1,
            4
          ]
        }
      ]
    }
  },
  {
    "id": "059",
    "tier": 6,
    "description": "Count subarrays with sum k.",
    "problem": "Return the number of contiguous subarrays whose sum equals k.",
    "function_signature": "def count_subarrays_sum_k(values, k):",
    "instruction": "Implement count_subarrays_sum_k(values, k) using deterministic logic.",
    "constraints": [
      "Values may include negatives",
      "Return integer count"
    ],
    "io_examples": [
      {
        "input": [
          [
            1,
            1,
            1
          ],
          2
        ],
        "output": 2
      },
      {
        "input": [
          [
            1,
            2,
            3
          ],
          3
        ],
        "output": 2
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def count_subarrays_sum_k(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "count_subarrays_sum_k",
      "examples": [
        {
          "args": [
            [
              1,
              1,
              1
            ],
            2
          ],
          "expected": 2
        },
        {
          "args": [
            [
              1,
              2,
              3
            ],
            3
          ],
          "expected": 2
        },
        {
          "args": [
            [
              1,
              -1,
              0
            ],
            0
          ],
          "expected": 3
        },
        {
          "args": [
            [],
            0
          ],
          "expected": 0
        }
      ]
    }
  },
  {
    "id": "060",
    "tier": 6,
    "description": "Asteroid collision simulation.",
    "problem": "Given integers representing moving asteroids, return state after all collisions. Positive moves right, negative moves left. Colliding asteroids destroy smaller absolute value; equal destroys both.",
    "function_signature": "def asteroid_collision(values):",
    "instruction": "Implement asteroid_collision(values) using stack-based deterministic logic.",
    "constraints": [
      "Return remaining asteroids in original relative order after collisions"
    ],
    "io_examples": [
      {
        "input": [
          [
            5,
            10,
            -5
          ]
        ],
        "output": [
          5,
          10
        ]
      },
      {
        "input": [
          [
            8,
            -8
          ]
        ],
        "output": []
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def asteroid_collision(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "asteroid_collision",
      "examples": [
        {
          "args": [
            [
              5,
              10,
              -5
            ]
          ],
          "expected": [
            5,
            10
          ]
        },
        {
          "args": [
            [
              8,
              -8
            ]
          ],
          "expected": []
        },
        {
          "args": [
            [
              10,
              2,
              -5
            ]
          ],
          "expected": [
            10
          ]
        },
        {
          "args": [
            [
              -2,
              -1,
              1,
              2
            ]
          ],
          "expected": [
            -2,
            -1,
            1,
            2
          ]
        }
      ]
    }
  },
  {
    "id": "061",
    "tier": 6,
    "description": "Decode ways count.",
    "problem": "Given digit string s where 1->A ... 26->Z, return number of valid decodings.",
    "function_signature": "def decode_ways_count(s):",
    "instruction": "Implement decode_ways_count(s).",
    "constraints": [
      "Return 0 for invalid encodings",
      "Use deterministic DP"
    ],
    "io_examples": [
      {
        "input": [
          "12"
        ],
        "output": 2
      },
      {
        "input": [
          "226"
        ],
        "output": 3
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def decode_ways_count(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "decode_ways_count",
      "examples": [
        {
          "args": [
            "12"
          ],
          "expected": 2
        },
        {
          "args": [
            "226"
          ],
          "expected": 3
        },
        {
          "args": [
            "06"
          ],
          "expected": 0
        }
      ]
    }
  },
  {
    "id": "062",
    "tier": 6,
    "description": "Generate valid parentheses.",
    "problem": "Return all valid parentheses combinations for n pairs, sorted lexicographically.",
    "function_signature": "def generate_parentheses(n):",
    "instruction": "Implement generate_parentheses(n).",
    "constraints": [
      "Deterministic lexicographic ordering required"
    ],
    "io_examples": [
      {
        "input": [
          3
        ],
        "output": [
          "((()))",
          "(()())",
          "(())()",
          "()(())",
          "()()()"
        ]
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def generate_parentheses(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "generate_parentheses",
      "examples": [
        {
          "args": [
            1
          ],
          "expected": [
            "()"
          ]
        },
        {
          "args": [
            3
          ],
          "expected": [
            "((()))",
            "(()())",
            "(())()",
            "()(())",
            "()()()"
          ]
        }
      ]
    }
  },
  {
    "id": "063",
    "tier": 6,
    "description": "Combination sum unique combinations.",
    "problem": "Return all unique combinations where candidates can be reused and sum equals target. Sort each combo and outer list lexicographically.",
    "function_signature": "def combination_sum(candidates, target):",
    "instruction": "Implement combination_sum(candidates, target).",
    "constraints": [
      "No duplicate combinations",
      "Deterministic sorted output"
    ],
    "io_examples": [
      {
        "input": [
          [
            2,
            3,
            6,
            7
          ],
          7
        ],
        "output": [
          [
            2,
            2,
            3
          ],
          [
            7
          ]
        ]
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def combination_sum(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "combination_sum",
      "examples": [
        {
          "args": [
            [
              2,
              3,
              6,
              7
            ],
            7
          ],
          "expected": [
            [
              2,
              2,
              3
            ],
            [
              7
            ]
          ]
        },
        {
          "args": [
            [
              2,
              3,
              5
            ],
            8
          ],
          "expected": [
            [
              2,
              2,
              2,
              2
            ],
            [
              2,
              3,
              3
            ],
            [
              3,
              5
            ]
          ]
        }
      ]
    }
  },
  {
    "id": "064",
    "tier": 6,
    "description": "Longest consecutive sequence length.",
    "problem": "Return the length of the longest run of consecutive integers in values.",
    "function_signature": "def longest_consecutive_length(values):",
    "instruction": "Implement longest_consecutive_length(values).",
    "constraints": [
      "Order of input does not matter",
      "Return integer length"
    ],
    "io_examples": [
      {
        "input": [
          [
            100,
            4,
            200,
            1,
            3,
            2
          ]
        ],
        "output": 4
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def longest_consecutive_length(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "longest_consecutive_length",
      "examples": [
        {
          "args": [
            [
              100,
              4,
              200,
              1,
              3,
              2
            ]
          ],
          "expected": 4
        },
        {
          "args": [
            [
              0,
              3,
              7,
              2,
              5,
              8,
              4,
              6,
              0,
              1
            ]
          ],
          "expected": 9
        },
        {
          "args": [
            []
          ],
          "expected": 0
        }
      ]
    }
  },
  {
    "id": "065",
    "tier": 6,
    "description": "Gas station circuit start index.",
    "problem": "Given gas and cost arrays, return start index to complete circuit once, or -1 if impossible.",
    "function_signature": "def gas_station_start(gas, cost):",
    "instruction": "Implement gas_station_start(gas, cost).",
    "constraints": [
      "If solution exists, return its index",
      "Return -1 when impossible"
    ],
    "io_examples": [
      {
        "input": [
          [
            1,
            2,
            3,
            4,
            5
          ],
          [
            3,
            4,
            5,
            1,
            2
          ]
        ],
        "output": 3
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def gas_station_start(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "gas_station_start",
      "examples": [
        {
          "args": [
            [
              1,
              2,
              3,
              4,
              5
            ],
            [
              3,
              4,
              5,
              1,
              2
            ]
          ],
          "expected": 3
        },
        {
          "args": [
            [
              2,
              3,
              4
            ],
            [
              3,
              4,
              3
            ]
          ],
          "expected": -1
        }
      ]
    }
  },
  {
    "id": "066",
    "tier": 6,
    "description": "Search 2D matrix.",
    "problem": "Given row-wise sorted matrix with first element of each row greater than last of previous row, return True if target exists.",
    "function_signature": "def search_matrix(matrix, target):",
    "instruction": "Implement search_matrix(matrix, target).",
    "constraints": [
      "Return boolean"
    ],
    "io_examples": [
      {
        "input": [
          [
            [
              1,
              3,
              5,
              7
            ],
            [
              10,
              11,
              16,
              20
            ],
            [
              23,
              30,
              34,
              60
            ]
          ],
          3
        ],
        "output": true
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def search_matrix(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "search_matrix",
      "examples": [
        {
          "args": [
            [
              [
                1,
                3,
                5,
                7
              ],
              [
                10,
                11,
                16,
                20
              ],
              [
                23,
                30,
                34,
                60
              ]
            ],
            3
          ],
          "expected": true
        },
        {
          "args": [
            [
              [
                1,
                3,
                5,
                7
              ],
              [
                10,
                11,
                16,
                20
              ],
              [
                23,
                30,
                34,
                60
              ]
            ],
            13
          ],
          "expected": false
        }
      ]
    }
  },
  {
    "id": "067",
    "tier": 6,
    "description": "Kth largest element.",
    "problem": "Return the kth largest element in an integer list.",
    "function_signature": "def kth_largest(values, k):",
    "instruction": "Implement kth_largest(values, k).",
    "constraints": [
      "1 <= k <= len(values)"
    ],
    "io_examples": [
      {
        "input": [
          [
            3,
            2,
            1,
            5,
            6,
            4
          ],
          2
        ],
        "output": 5
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def kth_largest(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "kth_largest",
      "examples": [
        {
          "args": [
            [
              3,
              2,
              1,
              5,
              6,
              4
            ],
            2
          ],
          "expected": 5
        },
        {
          "args": [
            [
              3,
              2,
              3,
              1,
              2,
              4,
              5,
              5,
              6
            ],
            4
          ],
          "expected": 4
        }
      ]
    }
  },
  {
    "id": "068",
    "tier": 6,
    "description": "Validate stack push/pop sequences.",
    "problem": "Return True if popped could be a valid pop sequence for pushed stack operations.",
    "function_signature": "def validate_stack_sequences(pushed, popped):",
    "instruction": "Implement validate_stack_sequences(pushed, popped).",
    "constraints": [
      "Return boolean"
    ],
    "io_examples": [
      {
        "input": [
          [
            1,
            2,
            3,
            4,
            5
          ],
          [
            4,
            5,
            3,
            2,
            1
          ]
        ],
        "output": true
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def validate_stack_sequences(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "validate_stack_sequences",
      "examples": [
        {
          "args": [
            [
              1,
              2,
              3,
              4,
              5
            ],
            [
              4,
              5,
              3,
              2,
              1
            ]
          ],
          "expected": true
        },
        {
          "args": [
            [
              1,
              2,
              3,
              4,
              5
            ],
            [
              4,
              3,
              5,
              1,
              2
            ]
          ],
          "expected": false
        }
      ]
    }
  },
  {
    "id": "069",
    "tier": 6,
    "description": "Minimum arrows for balloons.",
    "problem": "Given intervals for balloons, return minimum arrows to burst all balloons.",
    "function_signature": "def min_arrows(points):",
    "instruction": "Implement min_arrows(points).",
    "constraints": [
      "Each point is [start,end]"
    ],
    "io_examples": [
      {
        "input": [
          [
            [
              10,
              16
            ],
            [
              2,
              8
            ],
            [
              1,
              6
            ],
            [
              7,
              12
            ]
          ]
        ],
        "output": 2
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def min_arrows(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "min_arrows",
      "examples": [
        {
          "args": [
            [
              [
                10,
                16
              ],
              [
                2,
                8
              ],
              [
                1,
                6
              ],
              [
                7,
                12
              ]
            ]
          ],
          "expected": 2
        },
        {
          "args": [
            [
              [
                1,
                2
              ],
              [
                3,
                4
              ],
              [
                5,
                6
              ],
              [
                7,
                8
              ]
            ]
          ],
          "expected": 4
        }
      ]
    }
  },
  {
    "id": "070",
    "tier": 6,
    "description": "Can attend all meetings.",
    "problem": "Given meeting intervals [start,end], return True if one person can attend all meetings with no overlap.",
    "function_signature": "def can_attend_all_meetings(intervals):",
    "instruction": "Implement can_attend_all_meetings(intervals).",
    "constraints": [
      "Return boolean",
      "Intervals that touch at end/start are non-overlapping"
    ],
    "io_examples": [
      {
        "input": [
          [
            [
              0,
              30
            ],
            [
              5,
              10
            ],
            [
              15,
              20
            ]
          ]
        ],
        "output": false
      },
      {
        "input": [
          [
            [
              7,
              10
            ],
            [
              2,
              4
            ]
          ]
        ],
        "output": true
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def can_attend_all_meetings(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "can_attend_all_meetings",
      "examples": [
        {
          "args": [
            [
              [
                0,
                30
              ],
              [
                5,
                10
              ],
              [
                15,
                20
              ]
            ]
          ],
          "expected": false
        },
        {
          "args": [
            [
              [
                7,
                10
              ],
              [
                2,
                4
              ]
            ]
          ],
          "expected": true
        },
        {
          "args": [
            [
              [
                1,
                2
              ],
              [
                2,
                3
              ],
              [
                3,
                4
              ]
            ]
          ],
          "expected": true
        }
      ]
    }
  },
  {
    "id": "071",
    "tier": 6,
    "description": "Network delay time.",
    "problem": "Given directed weighted times [u,v,w], return time for all nodes to receive signal from k, or -1 if unreachable.",
    "function_signature": "def network_delay_time(times, n, k):",
    "instruction": "Implement network_delay_time(times, n, k).",
    "constraints": [
      "Nodes are labeled 1..n"
    ],
    "io_examples": [
      {
        "input": [
          [
            [
              2,
              1,
              1
            ],
            [
              2,
              3,
              1
            ],
            [
              3,
              4,
              1
            ]
          ],
          4,
          2
        ],
        "output": 2
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def network_delay_time(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "network_delay_time",
      "examples": [
        {
          "args": [
            [
              [
                2,
                1,
                1
              ],
              [
                2,
                3,
                1
              ],
              [
                3,
                4,
                1
              ]
            ],
            4,
            2
          ],
          "expected": 2
        },
        {
          "args": [
            [
              [
                1,
                2,
                1
              ]
            ],
            2,
            1
          ],
          "expected": 1
        },
        {
          "args": [
            [
              [
                1,
                2,
                1
              ]
            ],
            2,
            2
          ],
          "expected": -1
        }
      ]
    }
  },
  {
    "id": "072",
    "tier": 6,
    "description": "Minimum path sum in grid.",
    "problem": "Return minimum sum path from top-left to bottom-right moving only right or down.",
    "function_signature": "def min_path_sum(grid):",
    "instruction": "Implement min_path_sum(grid).",
    "constraints": [
      "Grid contains non-negative integers"
    ],
    "io_examples": [
      {
        "input": [
          [
            [
              1,
              3,
              1
            ],
            [
              1,
              5,
              1
            ],
            [
              4,
              2,
              1
            ]
          ]
        ],
        "output": 7
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def min_path_sum(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "min_path_sum",
      "examples": [
        {
          "args": [
            [
              [
                1,
                3,
                1
              ],
              [
                1,
                5,
                1
              ],
              [
                4,
                2,
                1
              ]
            ]
          ],
          "expected": 7
        },
        {
          "args": [
            [
              [
                1,
                2,
                3
              ],
              [
                4,
                5,
                6
              ]
            ]
          ],
          "expected": 12
        },
        {
          "args": [
            [
              [
                5
              ]
            ]
          ],
          "expected": 5
        }
      ]
    }
  },
  {
    "id": "073",
    "tier": 6,
    "description": "Reconstruct itinerary.",
    "problem": "Given flight tickets [from,to], reconstruct itinerary starting at JFK using all tickets exactly once. If multiple, return lexicographically smallest itinerary.",
    "function_signature": "def reconstruct_itinerary(tickets):",
    "instruction": "Implement reconstruct_itinerary(tickets).",
    "constraints": [
      "Use all tickets once",
      "Deterministic lexicographic result"
    ],
    "io_examples": [
      {
        "input": [
          [
            [
              "MUC",
              "LHR"
            ],
            [
              "JFK",
              "MUC"
            ],
            [
              "SFO",
              "SJC"
            ],
            [
              "LHR",
              "SFO"
            ]
          ]
        ],
        "output": [
          "JFK",
          "MUC",
          "LHR",
          "SFO",
          "SJC"
        ]
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def reconstruct_itinerary(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "reconstruct_itinerary",
      "examples": [
        {
          "args": [
            [
              [
                "MUC",
                "LHR"
              ],
              [
                "JFK",
                "MUC"
              ],
              [
                "SFO",
                "SJC"
              ],
              [
                "LHR",
                "SFO"
              ]
            ]
          ],
          "expected": [
            "JFK",
            "MUC",
            "LHR",
            "SFO",
            "SJC"
          ]
        },
        {
          "args": [
            [
              [
                "JFK",
                "KUL"
              ],
              [
                "JFK",
                "NRT"
              ],
              [
                "NRT",
                "JFK"
              ]
            ]
          ],
          "expected": [
            "JFK",
            "NRT",
            "JFK",
            "KUL"
          ]
        }
      ]
    }
  },
  {
    "id": "074",
    "tier": 6,
    "description": "Minimum genetic mutation steps.",
    "problem": "Return minimum mutations to change start to end using bank, changing one character each step.",
    "function_signature": "def min_genetic_mutation(start, end, bank):",
    "instruction": "Implement min_genetic_mutation(start, end, bank).",
    "constraints": [
      "Return -1 if impossible"
    ],
    "io_examples": [
      {
        "input": [
          "AACCGGTT",
          "AACCGGTA",
          [
            "AACCGGTA"
          ]
        ],
        "output": 1
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def min_genetic_mutation(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "min_genetic_mutation",
      "examples": [
        {
          "args": [
            "AACCGGTT",
            "AACCGGTA",
            [
              "AACCGGTA"
            ]
          ],
          "expected": 1
        },
        {
          "args": [
            "AACCGGTT",
            "AAACGGTA",
            [
              "AACCGGTA",
              "AACCGCTA",
              "AAACGGTA"
            ]
          ],
          "expected": 2
        },
        {
          "args": [
            "AAAAACCC",
            "AACCCCCC",
            [
              "AAAACCCC",
              "AAACCCCC",
              "AACCCCCC"
            ]
          ],
          "expected": 3
        }
      ]
    }
  },
  {
    "id": "075",
    "tier": 6,
    "description": "Open lock minimum turns.",
    "problem": "Return minimum turns to open lock from 0000 to target avoiding deadends.",
    "function_signature": "def open_lock_min_turns(deadends, target):",
    "instruction": "Implement open_lock_min_turns(deadends, target). If \"0000\" is in deadends, immediately return -1.",
    "constraints": [
      "Return -1 if unreachable",
      "Handle deadend at start state"
    ],
    "io_examples": [
      {
        "input": [
          [
            "0201",
            "0101",
            "0102",
            "1212",
            "2002"
          ],
          "0202"
        ],
        "output": 6
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def open_lock_min_turns(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "open_lock_min_turns",
      "examples": [
        {
          "args": [
            [
              "0201",
              "0101",
              "0102",
              "1212",
              "2002"
            ],
            "0202"
          ],
          "expected": 6
        },
        {
          "args": [
            [
              "8888"
            ],
            "0009"
          ],
          "expected": 1
        },
        {
          "args": [
            [
              "0000"
            ],
            "8888"
          ],
          "expected": -1
        }
      ]
    }
  },
  {
    "id": "076",
    "tier": 6,
    "description": "Word search in grid.",
    "problem": "Return True if word exists in grid by adjacent horizontal/vertical moves without reusing a cell.",
    "function_signature": "def word_exists(board, word):",
    "instruction": "Implement word_exists(board, word).",
    "constraints": [
      "Do not reuse same cell in one path"
    ],
    "io_examples": [
      {
        "input": [
          [
            [
              "A",
              "B",
              "C",
              "E"
            ],
            [
              "S",
              "F",
              "C",
              "S"
            ],
            [
              "A",
              "D",
              "E",
              "E"
            ]
          ],
          "ABCCED"
        ],
        "output": true
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def word_exists(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "word_exists",
      "examples": [
        {
          "args": [
            [
              [
                "A",
                "B",
                "C",
                "E"
              ],
              [
                "S",
                "F",
                "C",
                "S"
              ],
              [
                "A",
                "D",
                "E",
                "E"
              ]
            ],
            "ABCCED"
          ],
          "expected": true
        },
        {
          "args": [
            [
              [
                "A",
                "B",
                "C",
                "E"
              ],
              [
                "S",
                "F",
                "C",
                "S"
              ],
              [
                "A",
                "D",
                "E",
                "E"
              ]
            ],
            "SEE"
          ],
          "expected": true
        },
        {
          "args": [
            [
              [
                "A",
                "B",
                "C",
                "E"
              ],
              [
                "S",
                "F",
                "C",
                "S"
              ],
              [
                "A",
                "D",
                "E",
                "E"
              ]
            ],
            "ABCB"
          ],
          "expected": false
        }
      ]
    }
  },
  {
    "id": "077",
    "tier": 6,
    "description": "Container with most water area.",
    "problem": "Given heights, return maximum area formed by two lines and x-axis.",
    "function_signature": "def max_container_area(heights):",
    "instruction": "Implement max_container_area(heights).",
    "constraints": [
      "Return integer area",
      "Use deterministic logic"
    ],
    "io_examples": [
      {
        "input": [
          [
            1,
            8,
            6,
            2,
            5,
            4,
            8,
            3,
            7
          ]
        ],
        "output": 49
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def max_container_area(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "max_container_area",
      "examples": [
        {
          "args": [
            [
              1,
              8,
              6,
              2,
              5,
              4,
              8,
              3,
              7
            ]
          ],
          "expected": 49
        },
        {
          "args": [
            [
              1,
              1
            ]
          ],
          "expected": 1
        },
        {
          "args": [
            [
              4,
              3,
              2,
              1,
              4
            ]
          ],
          "expected": 16
        }
      ]
    }
  },
  {
    "id": "078",
    "tier": 6,
    "description": "Maximal square area.",
    "problem": "Given binary matrix of 0/1 strings, return area of largest square containing only 1s.",
    "function_signature": "def maximal_square_area(matrix):",
    "instruction": "Implement maximal_square_area(matrix).",
    "constraints": [
      "Return area not side length"
    ],
    "io_examples": [
      {
        "input": [
          [
            [
              "1",
              "0",
              "1",
              "0",
              "0"
            ],
            [
              "1",
              "0",
              "1",
              "1",
              "1"
            ],
            [
              "1",
              "1",
              "1",
              "1",
              "1"
            ],
            [
              "1",
              "0",
              "0",
              "1",
              "0"
            ]
          ]
        ],
        "output": 4
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def maximal_square_area(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "maximal_square_area",
      "examples": [
        {
          "args": [
            [
              [
                "1",
                "0",
                "1",
                "0",
                "0"
              ],
              [
                "1",
                "0",
                "1",
                "1",
                "1"
              ],
              [
                "1",
                "1",
                "1",
                "1",
                "1"
              ],
              [
                "1",
                "0",
                "0",
                "1",
                "0"
              ]
            ]
          ],
          "expected": 4
        },
        {
          "args": [
            [
              [
                "0",
                "1"
              ],
              [
                "1",
                "0"
              ]
            ]
          ],
          "expected": 1
        },
        {
          "args": [
            [
              [
                "0"
              ]
            ]
          ],
          "expected": 0
        }
      ]
    }
  },
  {
    "id": "079",
    "tier": 6,
    "description": "Maximum product subarray.",
    "problem": "Return the maximum product of any contiguous subarray.",
    "function_signature": "def max_product_subarray(values):",
    "instruction": "Implement max_product_subarray(values).",
    "constraints": [
      "Input non-empty",
      "Values may be negative or zero"
    ],
    "io_examples": [
      {
        "input": [
          [
            2,
            3,
            -2,
            4
          ]
        ],
        "output": 6
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def max_product_subarray(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "max_product_subarray",
      "examples": [
        {
          "args": [
            [
              2,
              3,
              -2,
              4
            ]
          ],
          "expected": 6
        },
        {
          "args": [
            [
              -2,
              0,
              -1
            ]
          ],
          "expected": 0
        },
        {
          "args": [
            [
              -2,
              3,
              -4
            ]
          ],
          "expected": 24
        }
      ]
    }
  },
  {
    "id": "080",
    "tier": 6,
    "description": "Find duplicate number in array.",
    "problem": "Given array values containing n+1 integers where each integer is in [1,n], return the duplicate number.",
    "function_signature": "def find_duplicate_number(values):",
    "instruction": "Implement find_duplicate_number(values).",
    "constraints": [
      "Exactly one duplicated value exists (may repeat more than twice)",
      "Return duplicated integer"
    ],
    "io_examples": [
      {
        "input": [
          [
            1,
            3,
            4,
            2,
            2
          ]
        ],
        "output": 2
      }
    ],
    "acceptance_contract": {
      "mode": "function",
      "required_artifacts": [
        "run.log",
        "report.json"
      ],
      "pass_conditions": [
        "Function returns expected values for examples",
        "Required artifacts are produced",
        "Task-level checks pass"
      ],
      "determinism_profile": "strict",
      "quality_required_keywords": [
        "def find_duplicate_number(",
        "return"
      ],
      "quality_forbidden_keywords": [
        "__main__",
        "print(",
        "run_cli",
        "log_crash"
      ]
    },
    "evaluation": {
      "type": "function_examples",
      "function_name": "find_duplicate_number",
      "examples": [
        {
          "args": [
            [
              1,
              3,
              4,
              2,
              2
            ]
          ],
          "expected": 2
        },
        {
          "args": [
            [
              3,
              1,
              3,
              4,
              2
            ]
          ],
          "expected": 3
        },
        {
          "args": [
            [
              2,
              2,
              2,
              2,
              2
            ]
          ],
          "expected": 2
        }
      ]
    }
  }
]
