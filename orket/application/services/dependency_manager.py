from __future__ import annotations

import asyncio
import json
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, Iterable, List, Mapping


@dataclass(frozen=True)
class DependencySpec:
    required_files: Dict[str, str]


class DependencyValidationError(Exception):
    """Raised when dependency stage validation fails."""


class DependencyManager:
    """
    Deterministic dependency stage.

    Owns dependency-manifest baseline files for generated projects.
    """

    _DEFAULT_FILES: Dict[str, str] = {
        "agent_output/dependencies/pyproject.toml": (
            "[project]\n"
            "name = \"orket-generated-project\"\n"
            "version = \"0.1.0\"\n"
            "description = \"Generated by Orket\"\n"
            "requires-python = \">=3.11\"\n"
            "dependencies = []\n"
        ),
        "agent_output/dependencies/requirements.txt": "",
        "agent_output/dependencies/package.json": (
            "{\n"
            "  \"name\": \"orket-generated-project\",\n"
            "  \"version\": \"0.1.0\",\n"
            "  \"private\": true,\n"
            "  \"scripts\": {\n"
            "    \"build\": \"echo build-not-configured\"\n"
            "  }\n"
            "}\n"
        ),
    }
    _MICROSERVICES_FILES: Dict[str, str] = {
        "agent_output/dependencies/microservices.json": (
            "{\n"
            "  \"services\": [\n"
            "    {\"name\": \"api\", \"path\": \"agent_output/services/api\"},\n"
            "    {\"name\": \"worker\", \"path\": \"agent_output/services/worker\"}\n"
            "  ]\n"
            "}\n"
        )
    }

    def __init__(
        self,
        workspace_root: Path,
        file_tools: Any,
        organization: Any = None,
        project_surface_profile: str | None = None,
        architecture_pattern: str | None = None,
    ):
        self.workspace_root = workspace_root
        self.file_tools = file_tools
        self.organization = organization
        self.project_surface_profile = str(project_surface_profile or "").strip().lower()
        self.architecture_pattern = str(architecture_pattern or "").strip().lower()

    async def ensure(self) -> Dict[str, Any]:
        spec = self._resolve_spec()
        created_files = await self._ensure_files(spec.required_files)
        await self._validate_required_files(spec.required_files)
        return {
            "created_files": created_files,
            "required_files": sorted(spec.required_files.keys()),
        }

    def _resolve_spec(self) -> DependencySpec:
        rules = {}
        if self.organization and isinstance(getattr(self.organization, "process_rules", None), dict):
            rules = self.organization.process_rules
        required_files = self._normalize_file_map(
            rules.get("dependency_manager_required_files"),
            self._DEFAULT_FILES,
        )
        stack_profile = str(rules.get("dependency_manager_stack_profile", "")).strip().lower()
        if not stack_profile:
            stack_profile = self._stack_profile_from_surface(
                self.project_surface_profile or str(rules.get("project_surface_profile", "unspecified")).strip().lower()
            )
        if not stack_profile:
            stack_profile = "polyglot"
        pinned_required = bool(rules.get("dependency_manager_require_pinned_versions", True))
        generated_files = self._build_profile_files(rules, stack_profile, pinned_required)
        if generated_files:
            required_files = generated_files
        architecture_pattern = self.architecture_pattern or str(
            rules.get("architecture_forced_pattern", "")
        ).strip().lower()
        if architecture_pattern == "microservices":
            required_files = {**required_files, **self._MICROSERVICES_FILES}
        return DependencySpec(required_files=dict(required_files))

    def _build_profile_files(
        self,
        rules: Mapping[str, Any],
        stack_profile: str,
        pinned_required: bool,
    ) -> Dict[str, str]:
        if stack_profile not in {"python", "node", "polyglot"}:
            stack_profile = "polyglot"

        files: Dict[str, str] = {}
        if stack_profile in {"python", "polyglot"}:
            py_deps = self._string_list(rules.get("dependency_manager_python_dependencies"))
            py_dev_deps = self._string_list(rules.get("dependency_manager_python_dev_dependencies"))
            if pinned_required:
                self._validate_pinned_python(py_deps + py_dev_deps)
            package_name = str(rules.get("dependency_manager_python_package_name", "orket-generated-project")).strip() or "orket-generated-project"
            package_version = str(rules.get("dependency_manager_python_package_version", "0.1.0")).strip() or "0.1.0"
            package_description = str(rules.get("dependency_manager_python_description", "Generated by Orket")).strip() or "Generated by Orket"
            requires_python = str(rules.get("dependency_manager_python_requires_python", ">=3.11")).strip() or ">=3.11"

            files["agent_output/dependencies/pyproject.toml"] = self._render_pyproject(
                name=package_name,
                version=package_version,
                description=package_description,
                requires_python=requires_python,
                dependencies=py_deps,
                dev_dependencies=py_dev_deps,
            )
            files["agent_output/dependencies/requirements.txt"] = self._render_requirements(py_deps)
            files["agent_output/dependencies/requirements-dev.txt"] = self._render_requirements(py_dev_deps)

        if stack_profile in {"node", "polyglot"}:
            node_deps = self._string_map(rules.get("dependency_manager_node_dependencies"))
            node_dev_deps = self._string_map(rules.get("dependency_manager_node_dev_dependencies"))
            profile = self.project_surface_profile or str(
                rules.get("project_surface_profile", "unspecified")
            ).strip().lower()
            if profile == "api_vue":
                node_deps = {
                    **{"vue": "3.5.13"},
                    **node_deps,
                }
                node_dev_deps = {
                    **{"vite": "5.4.12"},
                    **node_dev_deps,
                }
            if pinned_required:
                self._validate_pinned_node(node_deps)
                self._validate_pinned_node(node_dev_deps)
            node_name = str(rules.get("dependency_manager_node_package_name", "orket-generated-project")).strip() or "orket-generated-project"
            node_version = str(rules.get("dependency_manager_node_package_version", "0.1.0")).strip() or "0.1.0"
            files["agent_output/dependencies/package.json"] = self._render_package_json(
                name=node_name,
                version=node_version,
                dependencies=node_deps,
                dev_dependencies=node_dev_deps,
            )
        return files

    @staticmethod
    def _stack_profile_from_surface(project_surface_profile: str) -> str:
        profile = str(project_surface_profile or "").strip().lower()
        if profile in {"backend_only", "cli", "tui"}:
            return "python"
        if profile == "api_vue":
            return "polyglot"
        return ""

    async def _ensure_files(self, required_files: Mapping[str, str]) -> List[str]:
        created: List[str] = []
        for rel_path, content in required_files.items():
            target = self.workspace_root / rel_path
            exists = await asyncio.to_thread(target.exists)
            if exists:
                continue
            await self.file_tools.write_file(rel_path, content)
            created.append(rel_path)
        return created

    async def _validate_required_files(self, required_files: Mapping[str, str]) -> None:
        missing = []
        for rel_path in required_files.keys():
            exists = await asyncio.to_thread((self.workspace_root / rel_path).is_file)
            if not exists:
                missing.append(rel_path)
        if missing:
            raise DependencyValidationError(
                "missing dependency files: " + ", ".join(sorted(missing))
            )

    @staticmethod
    def _normalize_file_map(raw: Any, default: Mapping[str, str]) -> Dict[str, str]:
        if isinstance(raw, dict):
            normalized = {}
            for key, value in raw.items():
                key_str = str(key).strip()
                if not key_str:
                    continue
                normalized[key_str] = str(value)
            if normalized:
                return normalized
        return dict(default)

    @staticmethod
    def _string_list(raw: Any) -> List[str]:
        if not isinstance(raw, Iterable) or isinstance(raw, (str, bytes, dict)):
            return []
        values: List[str] = []
        for item in raw:
            text = str(item).strip()
            if text:
                values.append(text)
        return values

    @staticmethod
    def _string_map(raw: Any) -> Dict[str, str]:
        if not isinstance(raw, Mapping):
            return {}
        out: Dict[str, str] = {}
        for key, value in raw.items():
            k = str(key).strip()
            v = str(value).strip()
            if not k or not v:
                continue
            out[k] = v
        return out

    @staticmethod
    def _validate_pinned_python(dependencies: List[str]) -> None:
        for dep in dependencies:
            if "==" in dep:
                continue
            if dep.startswith("git+"):
                continue
            raise DependencyValidationError(
                f"python dependency '{dep}' is not pinned. Expected exact version (==)."
            )

    @staticmethod
    def _validate_pinned_node(dependencies: Dict[str, str]) -> None:
        for name, version in dependencies.items():
            # allow exact semver only by default
            if version and version[0].isdigit():
                continue
            raise DependencyValidationError(
                f"node dependency '{name}' has non-pinned version '{version}'."
            )

    @staticmethod
    def _render_pyproject(
        *,
        name: str,
        version: str,
        description: str,
        requires_python: str,
        dependencies: List[str],
        dev_dependencies: List[str],
    ) -> str:
        deps_json = json.dumps(dependencies, ensure_ascii=False)
        lines = [
            "[project]",
            f'name = "{name}"',
            f'version = "{version}"',
            f'description = "{description}"',
            f'requires-python = "{requires_python}"',
            f"dependencies = {deps_json}",
            "",
        ]
        if dev_dependencies:
            dev_json = json.dumps(dev_dependencies, ensure_ascii=False)
            lines.extend([
                "[project.optional-dependencies]",
                f"dev = {dev_json}",
                "",
            ])
        return "\n".join(lines)

    @staticmethod
    def _render_requirements(dependencies: List[str]) -> str:
        if not dependencies:
            return ""
        return "\n".join(dependencies) + "\n"

    @staticmethod
    def _render_package_json(
        *,
        name: str,
        version: str,
        dependencies: Dict[str, str],
        dev_dependencies: Dict[str, str],
    ) -> str:
        payload = {
            "name": name,
            "version": version,
            "private": True,
            "scripts": {
                "build": "echo build-not-configured",
            },
        }
        if dependencies:
            payload["dependencies"] = dict(sorted(dependencies.items()))
        if dev_dependencies:
            payload["devDependencies"] = dict(sorted(dev_dependencies.items()))
        return json.dumps(payload, indent=2, ensure_ascii=False) + "\n"
